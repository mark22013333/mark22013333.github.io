<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>從 Identity 欄位極限值看資料庫運作：實戰查詢範例分享</title>
      <link href="/2025/03/08/%E5%BE%9E%20Identity%20%E6%AC%84%E4%BD%8D%E6%A5%B5%E9%99%90%E5%80%BC%E7%9C%8B%E8%B3%87%E6%96%99%E5%BA%AB%E9%81%8B%E4%BD%9C%EF%BC%9A%E5%AF%A6%E6%88%B0%E6%9F%A5%E8%A9%A2%E7%AF%84%E4%BE%8B%E5%88%86%E4%BA%AB/"/>
      <url>/2025/03/08/%E5%BE%9E%20Identity%20%E6%AC%84%E4%BD%8D%E6%A5%B5%E9%99%90%E5%80%BC%E7%9C%8B%E8%B3%87%E6%96%99%E5%BA%AB%E9%81%8B%E4%BD%9C%EF%BC%9A%E5%AF%A6%E6%88%B0%E6%9F%A5%E8%A9%A2%E7%AF%84%E4%BE%8B%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>在這篇文章中，我想跟各位分享一個相當有趣又實用的 SQL 查詢範例。這支查詢主要用來檢查資料庫中各個資料表的 Identity 欄位（通常作為主鍵使用）的目前值（last_value），並根據該欄位的資料型態來推算其可能達到的最大極限值。</p><hr><h3 id="查詢範例"><a href="#查詢範例" class="headerlink" title="查詢範例"></a>查詢範例</h3><p>以下就是完整的 SQL 查詢程式碼：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OBJECT_NAME(ic.object_id) <span class="keyword">AS</span> TableName,</span><br><span class="line">       ic.name                   <span class="keyword">AS</span> IdentityColumn,</span><br><span class="line">       ic.last_value             <span class="keyword">AS</span> CurrentValue,</span><br><span class="line">       <span class="keyword">CASE</span></span><br><span class="line">           <span class="keyword">WHEN</span> ty.name <span class="operator">=</span> <span class="string">&#x27;tinyint&#x27;</span> <span class="keyword">THEN</span> <span class="number">255</span></span><br><span class="line">           <span class="keyword">WHEN</span> ty.name <span class="operator">=</span> <span class="string">&#x27;smallint&#x27;</span> <span class="keyword">THEN</span> <span class="number">32767</span></span><br><span class="line">           <span class="keyword">WHEN</span> ty.name <span class="operator">=</span> <span class="string">&#x27;int&#x27;</span> <span class="keyword">THEN</span> <span class="number">2147483647</span></span><br><span class="line">           <span class="keyword">WHEN</span> ty.name <span class="operator">=</span> <span class="string">&#x27;bigint&#x27;</span> <span class="keyword">THEN</span> <span class="number">9223372036854775807</span></span><br><span class="line">           <span class="keyword">ELSE</span> N<span class="string">&#x27;非數值型態&#x27;</span></span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">AS</span> MaxPossibleValue</span><br><span class="line"><span class="keyword">FROM</span> sys.identity_columns ic</span><br><span class="line">         <span class="keyword">JOIN</span> sys.columns c</span><br><span class="line">              <span class="keyword">ON</span> ic.object_id <span class="operator">=</span> c.object_id <span class="keyword">AND</span> ic.column_id <span class="operator">=</span> c.column_id</span><br><span class="line">         <span class="keyword">JOIN</span> sys.types ty</span><br><span class="line">              <span class="keyword">ON</span> c.user_type_id <span class="operator">=</span> ty.user_type_id</span><br><span class="line"><span class="keyword">WHERE</span> ic.last_value <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="分步解析"><a href="#分步解析" class="headerlink" title="分步解析"></a>分步解析</h3><h3 id="1-取得關鍵資訊"><a href="#1-取得關鍵資訊" class="headerlink" title="1. 取得關鍵資訊"></a>1. 取得關鍵資訊</h3><ul><li><strong>TableName</strong>：利用 <code>OBJECT_NAME(ic.object_id)</code> 將物件 ID 轉換成易讀的資料表名稱。</li><li><strong>IdentityColumn</strong>：藉由 <code>ic.name</code> 直接取得 Identity 欄位的名稱，讓你一眼就知道是哪個欄位在運作。</li><li><strong>CurrentValue</strong>：<code>ic.last_value</code> 代表目前該 Identity 欄位最後使用的數值，也就是下次插入資料時所會用到的數字。</li></ul><h3 id="2-計算型態的極限值"><a href="#2-計算型態的極限值" class="headerlink" title="2. 計算型態的極限值"></a>2. 計算型態的極限值</h3><p>這裡我們運用 <code>CASE</code> 語句，根據不同的數值型態，給出各自的最大可能值：</p><ul><li><strong>tinyint</strong>：最大值為 255。</li><li><strong>smallint</strong>：最大值為 32767。</li><li><strong>int</strong>：最大值為 2147483647。</li><li><strong>bigint</strong>：最大值為 9223372036854775807。</li><li>若欄位型態非上述數值型態，則回傳「非數值型態」。</li></ul><p>這個邏輯能夠快速算出每個 Identity 欄位還有多少數值空間，幫助我們在系統接近極限前做好預防措施。</p><h3 id="3-連結系統檢視表"><a href="#3-連結系統檢視表" class="headerlink" title="3. 連結系統檢視表"></a>3. 連結系統檢視表</h3><ul><li><strong>sys.identity_columns</strong>：此系統檢視表保存了所有具有 Identity 屬性的欄位資訊。</li><li><strong>sys.columns</strong> 與 <strong>sys.types</strong>：分別提供欄位的詳細資料與型態資訊，讓我們能根據資料型態正確計算出極限值。</li></ul><h3 id="4-篩選條件"><a href="#4-篩選條件" class="headerlink" title="4. 篩選條件"></a>4. 篩選條件</h3><ul><li><code>WHERE ic.last_value &gt; 50</code>：這個篩選條件只針對目前數值大於 50 的 Identity 欄位進行查詢，數值可以依照實際情況調整，讓你只聚焦在可能接近極限的那些資料表上。</li></ul><hr><h3 id="實際應用場景"><a href="#實際應用場景" class="headerlink" title="實際應用場景"></a>實際應用場景</h3><p>在大型應用系統中，許多專案會採用 Identity 欄位來作為主要的主鍵生成機制。隨著資料量不斷累加，Identity 欄位的數值也會逐漸逼近其資料型態所能表示的極限值。當這個狀況發生時，若沒有提前預防，就可能造成數值溢出。此時，你可以利用這支查詢快速掌握哪些資料表已經快到臨界點，並採取必要的措施（例如改變欄位型態或重設序列），確保系統的穩定與安全。</p><hr><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這支查詢範例不僅展示了如何運用 MSSQL 的系統檢視表來取得 Identity 欄位的現況，還結合了資料型態的知識來推算每個欄位的最大極限值。對資料庫管理員和開發團隊來說，這都是一個極具參考價值的工具，可以在系統運行過程中及早預防潛在問題。希望透過這篇文章，大家能在日常的資料庫管理中多一份安心！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 資料庫(MSSQL) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSSQL </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料表重新建立及資料遷移 SOP</title>
      <link href="/2025/02/24/%E8%B3%87%E6%96%99%E8%A1%A8%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8B%E5%8F%8A%E8%B3%87%E6%96%99%E9%81%B7%E7%A7%BB-SOP/"/>
      <url>/2025/02/24/%E8%B3%87%E6%96%99%E8%A1%A8%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8B%E5%8F%8A%E8%B3%87%E6%96%99%E9%81%B7%E7%A7%BB-SOP/</url>
      
        <content type="html"><![CDATA[<p>💡 <strong>Purpose:</strong>  此 SOP 說明如何從原始資料表進行備份、建立新表、資料遷移以及重新命名，目的是因應原資料表主鍵未設定自動遞增，需先備份資料，再依新的 DDL 語法建立自動遞增主鍵的表結構，最後將資料還原。請務必在每個步驟執行前確認相關操作已備份完成，以避免資料遺失。</p><h2 id="前置檢查"><a href="#前置檢查" class="headerlink" title="前置檢查"></a>前置檢查</h2><p><strong>步驟 0：檢查表結構與資料筆數</strong></p><ol><li><p>取得資料表結構，確認是否已有自動遞增主鍵。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> sp_columns WCSTXXX;</span><br></pre></td></tr></table></figure></li><li><p>檢查主鍵（例如：WCSID）是否有重複筆數：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> WCSID, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> WCSTXXX</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> WCSID</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>檢查資料表的總筆數：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> WCSTXXX;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意： 請將檢查結果記錄下來，作為後續參考依據。</p></blockquote><hr><h2 id="備份原始資料"><a href="#備份原始資料" class="headerlink" title="備份原始資料"></a>備份原始資料</h2><p><strong>步驟 1：備份現有資料表</strong></p><p>將現有資料完整備份至另一張暫存表中，避免後續操作造成資料遺失：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> backup_WCSTXXX <span class="keyword">from</span> WCSTXXX;</span><br></pre></td></tr></table></figure><hr><h2 id="建立新資料表"><a href="#建立新資料表" class="headerlink" title="建立新資料表"></a>建立新資料表</h2><p><strong>步驟 2：產出並修改 DDL 語法</strong></p><ol><li><p>從現有資料表產生 DDL 語法，並依下列需求修改：</p><ul><li>修改<strong>TABLE NAME</strong>（例如：由 WCSTXXX 變更為 WCSTXXX_New）</li><li>修改主鍵敘述（PRIMARY KEY CLUSTERED），設定主鍵欄位 WCSID 為自動遞增（identity(1,1)）</li></ul></li><li><p>修改後的範例如下（僅示範部分語法，其他欄位請依實際情形補上）：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">USE [WCS];</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** Object:  Table [dbo].[WCSTXXX]    Script Date: 02/24/2025 15:17:24 ******/</span></span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [dbo].[WCSTXXX_New](</span><br><span class="line">    [WCSID] [<span class="type">int</span>] <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="comment">-- 其他欄位請依照原資料表定義補上，例如：</span></span><br><span class="line">    [TITLE] NVARCHAR(<span class="number">255</span>),</span><br><span class="line">    [CONTENT] NVARCHAR(MAX),</span><br><span class="line">    [PUBLISH_DATE] DATETIME,</span><br><span class="line">    [EXTRACT_DATE] DATETIME,</span><br><span class="line">    [WEBURL] NVARCHAR(<span class="number">255</span>),</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> [PK_WCSTXXX] <span class="keyword">PRIMARY</span> KEY CLUSTERED</span><br><span class="line">(</span><br><span class="line">    [WCSID] <span class="keyword">ASC</span></span><br><span class="line">) <span class="keyword">WITH</span> (PAD_INDEX  <span class="operator">=</span> OFF, STATISTICS_NORECOMPUTE  <span class="operator">=</span> OFF, IGNORE_DUP_KEY <span class="operator">=</span> OFF, ALLOW_ROW_LOCKS  <span class="operator">=</span> <span class="keyword">ON</span>, ALLOW_PAGE_LOCKS  <span class="operator">=</span> <span class="keyword">ON</span>) <span class="keyword">ON</span> [<span class="keyword">PRIMARY</span>]</span><br><span class="line">) <span class="keyword">ON</span> [<span class="keyword">PRIMARY</span>];</span><br><span class="line">GO</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>提醒： 確認語法修改正確後再執行建立新表的指令。</p></blockquote><hr><h2 id="資料遷移"><a href="#資料遷移" class="headerlink" title="資料遷移"></a>資料遷移</h2><p><strong>步驟 3：將備份資料寫入新建立的表</strong></p><p>將備份表中的資料寫入新表（注意：此處只針對非自動遞增的欄位進行遷移）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> WCSTXXX_New (TITLE, CONTENT, PUBLISH_DATE, EXTRACT_DATE, WEBURL)</span><br><span class="line"><span class="keyword">select</span> TITLE, CONTENT, PUBLISH_DATE, EXTRACT_DATE, WEBURL</span><br><span class="line"><span class="keyword">from</span> backup_WCSTXXX;</span><br></pre></td></tr></table></figure><p><strong>步驟 4：清空原始資料表</strong></p><p><strong>請再次確認備份完成後</strong>，使用 <code>TRUNCATE</code> 清空原始資料表，確保無遺漏資料：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> WCSTXXX;</span><br></pre></td></tr></table></figure><p><strong>步驟 5：將新資料寫回原始表</strong></p><p>由於原資料表原先沒有自動遞增主鍵，因此在備份時主鍵欄位已有值，需用事前準備好的 DML 語法將資料（包含主鍵）寫回原表。</p><p>範例如下（請依實際欄位補全 DML 語法）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [dbo].[WCSTXXX] ([WCSID], TITLE, CONTENT, PUBLISH_DATE, EXTRACT_DATE, WEBURL)</span><br><span class="line"><span class="comment">-- 此處資料來源依照需求調整</span></span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( ... ),</span><br><span class="line">( ... );</span><br></pre></td></tr></table></figure><p><strong>步驟 6：將原始表最新資料再寫入新表</strong></p><p>完成原始表資料寫入後，再將最新資料遷移到新建立的表，確保兩表資料同步：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> WCSTXXX_New (TITLE, CONTENT, PUBLISH_DATE, EXTRACT_DATE, WEBURL)</span><br><span class="line"><span class="keyword">select</span> TITLE, CONTENT, PUBLISH_DATE, EXTRACT_DATE, WEBURL</span><br><span class="line"><span class="keyword">from</span> WCSTXXX;</span><br></pre></td></tr></table></figure><hr><h2 id="最終確認與表結構變更"><a href="#最終確認與表結構變更" class="headerlink" title="最終確認與表結構變更"></a>最終確認與表結構變更</h2><p><strong>步驟 7：檢查筆數</strong></p><p>確認新表、備份表及原始表的筆數，確保資料一致：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> WCSTXXX_New;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> backup_WCSTXXX;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> WCSTXXX;</span><br></pre></td></tr></table></figure><p><strong>步驟 8：刪除原始表</strong></p><p>在確認資料完全遷移並備份無誤後，可刪除原始資料表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> WCSTXXX;</span><br></pre></td></tr></table></figure><p><strong>步驟 9：重新命名表格</strong></p><p>將備份表與新建立的表重新命名，以達到以下目的：</p><ul><li>將原始表備份命名為 <code>WCSTXXX_Old</code></li><li>將新建立的表命名為原始表名稱 <code>WCSTXXX</code>執行以下指令：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_rename <span class="string">&#x27;backup_WCSTXXX&#x27;</span>, <span class="string">&#x27;WCSTXXX_Old&#x27;</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_rename <span class="string">&#x27;WCSTXXX_New&#x27;</span>, <span class="string">&#x27;WCSTXXX&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h2><ul><li><strong>執行前確認：</strong> 每個步驟執行前請務必確認所有資料均已備份，避免操作失誤造成資料遺失。</li><li><strong>程式碼調整：</strong> 此文件中的 SQL 範例僅供參考，請依據實際資料表結構與業務需求進行調整。</li><li><strong>版本控管：</strong> 建議在操作前後記錄相關版本及執行日期，方便後續追蹤與還原。</li></ul><h2 id="資料正確性驗證"><a href="#資料正確性驗證" class="headerlink" title="資料正確性驗證"></a>資料正確性驗證</h2><p><strong>步驟 10：快速驗證資料正確性</strong></p><ol><li><p>使用 TOP 指令抽樣檢查資料：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 檢查新舊表格的前N筆資料是否一致</span></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">10</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> WCSTXXX</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> WCSID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">10</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> WCSTXXX_Old</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> WCSID;</span><br></pre></td></tr></table></figure></li><li><p>使用 CHECKSUM 比對資料：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用CHECKSUM比對重要欄位</span></span><br><span class="line"><span class="keyword">SELECT</span> CHECKSUM_AGG(CHECKSUM(<span class="operator">*</span>))</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> TITLE, CONTENT, PUBLISH_DATE, EXTRACT_DATE, WEBURL</span><br><span class="line">      <span class="keyword">FROM</span> WCSTXXX) <span class="keyword">AS</span> T1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CHECKSUM_AGG(CHECKSUM(<span class="operator">*</span>))</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> TITLE, CONTENT, PUBLISH_DATE, EXTRACT_DATE, WEBURL</span><br><span class="line">      <span class="keyword">FROM</span> WCSTXXX_Old) <span class="keyword">AS</span> T2;</span><br></pre></td></tr></table></figure></li><li><p>檢查關鍵欄位的統計資訊：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 檢查日期範圍</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(PUBLISH_DATE), <span class="built_in">MAX</span>(PUBLISH_DATE), <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> WCSTXXX;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 檢查NULL值數量</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> TITLE <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">END</span>) <span class="keyword">as</span> NULL_TITLE_COUNT,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> CONTENT <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">END</span>) <span class="keyword">as</span> NULL_CONTENT_COUNT</span><br><span class="line"><span class="keyword">FROM</span> WCSTXXX;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 資料庫(MSSQL) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSSQL </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>統計資料庫所有表的筆數與完整性校驗（CheckSum）</title>
      <link href="/2025/02/20/%E7%B5%B1%E8%A8%88%E8%B3%87%E6%96%99%E5%BA%AB%E6%89%80%E6%9C%89%E8%A1%A8%E7%9A%84%E7%AD%86%E6%95%B8%E8%88%87%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%A9%97%EF%BC%88CheckSum%EF%BC%89/"/>
      <url>/2025/02/20/%E7%B5%B1%E8%A8%88%E8%B3%87%E6%96%99%E5%BA%AB%E6%89%80%E6%9C%89%E8%A1%A8%E7%9A%84%E7%AD%86%E6%95%B8%E8%88%87%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%A9%97%EF%BC%88CheckSum%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>今天來分享幾個在 SQL Server 2008 裡，如何比對資料表內容的小技巧，讓你可以快速檢查資料是否有異動。以下會介紹三種方法，分別適用於不同的情境，親自實測過，效果滿不錯的喔！</p><hr><h2 id="方法-1：用-CHECKSUM-AGG-來計算表格變更"><a href="#方法-1：用-CHECKSUM-AGG-來計算表格變更" class="headerlink" title="方法 1：用 CHECKSUM_AGG 來計算表格變更"></a>方法 1：用 CHECKSUM_AGG 來計算表格變更</h2><p>這個方法是利用 <code>CHECKSUM_AGG(BINARY_CHECKSUM(*))</code> 來算出整個資料表的檢查碼。它的優點就是運算速度快，不會遇到像 XML 轉換那種限制，缺點則是有可能會發生碰撞（就是不同資料卻得到一樣的檢查碼），而且對於 BLOB 或浮點數欄位就不太適合。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.name <span class="keyword">AS</span> SchemaName,</span><br><span class="line">    t.name <span class="keyword">AS</span> TableName,</span><br><span class="line">    CHECKSUM_AGG(BINARY_CHECKSUM(<span class="operator">*</span>)) <span class="keyword">AS</span> TableChecksum</span><br><span class="line"><span class="keyword">FROM</span> sys.tables t</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.schemas s <span class="keyword">ON</span> t.schema_id <span class="operator">=</span> s.schema_id</span><br><span class="line"><span class="keyword">WHERE</span> s.name <span class="operator">=</span> <span class="string">&#x27;dbo&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s.name, t.name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s.name, t.name;</span><br></pre></td></tr></table></figure><p><strong>小提醒：</strong></p><ul><li><strong>BINARY_CHECKSUM(*)</strong> 會根據一筆資料的所有欄位來算出一個整數檢查碼。</li><li><strong>CHECKSUM_AGG</strong> 則是把每筆資料的檢查碼加總起來，得出整張表的綜合檢查碼。</li></ul><hr><h2 id="方法-2：統計各資料表的筆數"><a href="#方法-2：統計各資料表的筆數" class="headerlink" title="方法 2：統計各資料表的筆數"></a>方法 2：統計各資料表的筆數</h2><p>如果你只是想知道每張資料表有多少筆資料，不用一個個 <code>COUNT(*)</code> 的話，可以利用系統檢視表 <code>sys.dm_db_partition_stats</code>，它可以很快地幫你統計 Heap 表和 Clustered Index 的資料列數。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.name           <span class="keyword">AS</span> SchemaName,</span><br><span class="line">       t.name           <span class="keyword">AS</span> TableName,</span><br><span class="line">       <span class="built_in">SUM</span>(p.row_count) <span class="keyword">AS</span> [RowCount]</span><br><span class="line"><span class="keyword">FROM</span> sys.tables t</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.schemas s <span class="keyword">ON</span> t.schema_id <span class="operator">=</span> s.schema_id</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.dm_db_partition_stats p <span class="keyword">ON</span> t.object_id <span class="operator">=</span> p.object_id</span><br><span class="line"><span class="keyword">WHERE</span> p.index_id <span class="keyword">IN</span> (<span class="number">0</span>, <span class="number">1</span>) <span class="comment">-- 0：Heap 表，1：Clustered Index</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s.name, t.name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s.name, t.name;</span><br></pre></td></tr></table></figure><p><strong>重點：</strong></p><ul><li>直接從系統檢視表取得筆數，比 <code>COUNT(*)</code> 效能更好！</li><li>記得用 <code>index_id IN (0, 1)</code> 過濾，只抓 Heap 表和 Clustered Index 的資料。</li></ul><hr><h2 id="方法-3：利用-SHA-256-算雜湊值來驗證資料完整性"><a href="#方法-3：利用-SHA-256-算雜湊值來驗證資料完整性" class="headerlink" title="方法 3：利用 SHA-256 算雜湊值來驗證資料完整性"></a>方法 3：利用 SHA-256 算雜湊值來驗證資料完整性</h2><p>若你對資料的完整性要求非常高，想要用更強的雜湊演算法（比如 SHA-256），那你可以考慮這個方法。不過這個方法會比 CHECKSUM_AGG 慢一點，而且在處理大量資料時，轉換成 XML 的部分可能會有點吃力。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 若 TableCursor 已存在，先釋放</span></span><br><span class="line">IF CURSOR_STATUS(<span class="string">&#x27;local&#x27;</span>, <span class="string">&#x27;TableCursor&#x27;</span>) <span class="operator">&gt;=</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">CLOSE</span> TableCursor;</span><br><span class="line">        <span class="keyword">DEALLOCATE</span> TableCursor;</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建立臨時表來存放雜湊結果</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> #HashResults</span><br><span class="line">(</span><br><span class="line">    TableName NVARCHAR(<span class="number">300</span>),</span><br><span class="line">    TableHash <span class="type">VARBINARY</span>(<span class="number">32</span>) <span class="comment">-- SHA2_256 的雜湊值長度為 32 bytes</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@FullTableName</span> NVARCHAR(<span class="number">300</span>),</span><br><span class="line">    <span class="variable">@SQL</span> NVARCHAR(MAX);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取得 dbo schema 下所有資料表</span></span><br><span class="line"><span class="keyword">DECLARE</span> TableCursor <span class="keyword">CURSOR</span> <span class="keyword">LOCAL</span> <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> QUOTENAME(s.name) <span class="operator">+</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">+</span> QUOTENAME(t.name) <span class="keyword">AS</span> FullTableName</span><br><span class="line">    <span class="keyword">FROM</span> sys.tables t</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.schemas s <span class="keyword">ON</span> t.schema_id <span class="operator">=</span> s.schema_id</span><br><span class="line">    <span class="keyword">WHERE</span> s.name <span class="operator">=</span> <span class="string">&#x27;dbo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">OPEN</span> TableCursor;</span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> TableCursor <span class="keyword">INTO</span> <span class="variable">@FullTableName</span>;</span><br><span class="line">WHILE @<span class="variable">@FETCH_STATUS</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">SET</span> <span class="variable">@SQL</span> <span class="operator">=</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    SELECT &#x27;&#x27;&#x27;</span> <span class="operator">+</span> <span class="variable">@FullTableName</span> <span class="operator">+</span> <span class="string">&#x27;&#x27;&#x27; AS TableName,</span></span><br><span class="line"><span class="string">           HASHBYTES(&#x27;&#x27;SHA2_256&#x27;&#x27;, (SELECT * FROM &#x27;</span> <span class="operator">+</span> <span class="variable">@FullTableName</span> <span class="operator">+</span> <span class="string">&#x27; FOR XML AUTO)) AS TableHash;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 執行動態 SQL 並將結果插入臨時表</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> #HashResults</span><br><span class="line">            <span class="keyword">EXEC</span> sp_executesql <span class="variable">@SQL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> TableCursor <span class="keyword">INTO</span> <span class="variable">@FullTableName</span>;</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CLOSE</span> TableCursor;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> TableCursor;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 輸出所有雜湊結果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> #HashResults;</span><br></pre></td></tr></table></figure><p><strong>說明一下：</strong></p><ul><li>這段程式碼利用動態 SQL 搭配 <code>HASHBYTES(&#39;SHA2_256&#39;, ...)</code> 來計算每張表的 SHA-256 雜湊值，並用 <code>FOR XML AUTO</code> 把表格內容轉換成 XML 字串。</li><li>為避免資源被 Cursor 長期佔用，程式碼開頭先檢查並釋放現有的 Cursor。</li><li>最後將所有結果匯總到臨時表，再一次性輸出。</li></ul><hr><h2 id="總結一下三種方法"><a href="#總結一下三種方法" class="headerlink" title="總結一下三種方法"></a>總結一下三種方法</h2><table><thead><tr><th>方法</th><th>適用情境</th><th>速度</th><th>準確性</th><th>可能遇到的問題</th></tr></thead><tbody><tr><td><code>CHECKSUM_AGG(BINARY_CHECKSUM(*))</code></td><td>快速檢查資料變更</td><td>★★★★★</td><td>★★☆☆☆</td><td>可能會碰撞，不適用部分欄位類型</td></tr><tr><td><code>sys.dm_db_partition_stats</code></td><td>統計各表筆數</td><td>★★★★★</td><td>N&#x2F;A</td><td>只能統計筆數，無法檢查內容變更</td></tr><tr><td><code>HASHBYTES(SHA2_256, FOR XML AUTO)</code></td><td>精確驗證資料完整性</td><td>★★☆☆☆</td><td>★★★★★</td><td>XML 轉換可能對大表有負擔</td></tr></tbody></table><p>如果你只是需要快速確認資料是否有異動，使用 <strong>CHECKSUM_AGG</strong> 是最方便又快速的方法；如果對資料完整性要求較高，又不怕花點資源，那就可以考慮用 <strong>SHA-256</strong> 的方式。不管是哪種方法，依照你的需求做選擇，才能兼顧效率和準確性！</p><p>希望這篇文章對你有幫助，有任何問題或心得歡迎留言分享！Happy coding～～</p><hr><p>後來有 DBA 提供的另外的寫法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@SQL</span> NVARCHAR(MAX);</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@CountSQL</span> NVARCHAR(MAX);</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@TableName</span> NVARCHAR(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@SchemaName</span> NVARCHAR(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@RecordCount</span> <span class="type">BIGINT</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@HasPK</span> BIT;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@PKColumns</span> NVARCHAR(MAX);</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@MaxRows</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">-- 設定最大資料列數</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@DataSize</span> <span class="type">INT</span> <span class="operator">=</span> <span class="number">4000</span>; <span class="comment">-- 設定最大資料大小，避免超過8000位元組的限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建立暫存表來存儲結果</span></span><br><span class="line">IF OBJECT_ID(<span class="string">&#x27;tempdb..#TableHashes&#x27;</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">TABLE</span> #TableHashes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> #TableHashes (</span><br><span class="line">    SchemaName NVARCHAR(<span class="number">128</span>),</span><br><span class="line">    TableName NVARCHAR(<span class="number">128</span>),</span><br><span class="line">    TableHash <span class="type">VARBINARY</span>(<span class="number">20</span>),</span><br><span class="line">    RecordCount <span class="type">BIGINT</span>,</span><br><span class="line">    UsedPK BIT,</span><br><span class="line">    ErrorMessage NVARCHAR(MAX) <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取得所有使用者資料表</span></span><br><span class="line"><span class="keyword">DECLARE</span> TableCursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name <span class="keyword">AS</span> SchemaName, t.name <span class="keyword">AS</span> TableName</span><br><span class="line"><span class="keyword">FROM</span> sys.tables t</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.schemas s <span class="keyword">ON</span> t.schema_id <span class="operator">=</span> s.schema_id</span><br><span class="line"><span class="comment">--WHERE t.name = &#x27;JMC_SMS&#x27;; -- 加入WHERE條件指定表名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">OPEN</span> TableCursor;</span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> TableCursor <span class="keyword">INTO</span> <span class="variable">@SchemaName</span>, <span class="variable">@TableName</span>;</span><br><span class="line"></span><br><span class="line">WHILE @<span class="variable">@FETCH_STATUS</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 計算資料筆數</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@CountSQL</span> <span class="operator">=</span> N<span class="string">&#x27;SELECT @RecordCount = COUNT(*) FROM &#x27;</span> <span class="operator">+</span> QUOTENAME(<span class="variable">@SchemaName</span>) <span class="operator">+</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">+</span> QUOTENAME(<span class="variable">@TableName</span>);</span><br><span class="line">    <span class="keyword">EXEC</span> sp_executesql <span class="variable">@CountSQL</span>, N<span class="string">&#x27;@RecordCount BIGINT OUTPUT&#x27;</span>, <span class="variable">@RecordCount</span> OUTPUT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 檢查表是否有主鍵</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@HasPK</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@PKColumns</span> <span class="operator">=</span> <span class="keyword">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@HasPK</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">           <span class="variable">@PKColumns</span> <span class="operator">=</span> STUFF((</span><br><span class="line">               <span class="keyword">SELECT</span> <span class="string">&#x27;, &#x27;</span> <span class="operator">+</span> QUOTENAME(c.name)</span><br><span class="line">               <span class="keyword">FROM</span> sys.indexes i</span><br><span class="line">               <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.index_columns ic <span class="keyword">ON</span> i.object_id <span class="operator">=</span> ic.object_id <span class="keyword">AND</span> i.index_id <span class="operator">=</span> ic.index_id</span><br><span class="line">               <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.columns c <span class="keyword">ON</span> ic.object_id <span class="operator">=</span> c.object_id <span class="keyword">AND</span> ic.column_id <span class="operator">=</span> c.column_id</span><br><span class="line">               <span class="keyword">WHERE</span> i.object_id <span class="operator">=</span> OBJECT_ID(<span class="variable">@SchemaName</span> <span class="operator">+</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">+</span> <span class="variable">@TableName</span>)</span><br><span class="line">               <span class="keyword">AND</span> i.is_primary_key <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">               <span class="keyword">ORDER</span> <span class="keyword">BY</span> ic.key_ordinal</span><br><span class="line">               <span class="keyword">FOR</span> XML PATH(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">           ), <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">FROM</span> sys.indexes i</span><br><span class="line">    <span class="keyword">WHERE</span> i.object_id <span class="operator">=</span> OBJECT_ID(<span class="variable">@SchemaName</span> <span class="operator">+</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">+</span> <span class="variable">@TableName</span>)</span><br><span class="line">    <span class="keyword">AND</span> i.is_primary_key <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 資料筆數為0的表視為雜湊計算成功</span></span><br><span class="line">    IF <span class="variable">@RecordCount</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> #TableHashes (SchemaName, TableName, TableHash, RecordCount, UsedPK, ErrorMessage)</span><br><span class="line">        <span class="keyword">VALUES</span> (<span class="variable">@SchemaName</span>, <span class="variable">@TableName</span>, HASHBYTES(<span class="string">&#x27;SHA1&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="number">0</span>, <span class="variable">@HasPK</span>, <span class="keyword">NULL</span>);</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- 如果有主鍵，使用主鍵欄位計算雜湊值</span></span><br><span class="line">        IF <span class="variable">@HasPK</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="keyword">SET</span> <span class="variable">@SQL</span> <span class="operator">=</span> N<span class="string">&#x27;</span></span><br><span class="line"><span class="string">            INSERT INTO #TableHashes (SchemaName, TableName, TableHash, RecordCount, UsedPK, ErrorMessage)</span></span><br><span class="line"><span class="string">            SELECT &#x27;&#x27;&#x27;</span> <span class="operator">+</span> <span class="variable">@SchemaName</span> <span class="operator">+</span> <span class="string">&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;</span> <span class="operator">+</span> <span class="variable">@TableName</span> <span class="operator">+</span> <span class="string">&#x27;&#x27;&#x27;,</span></span><br><span class="line"><span class="string">                   HASHBYTES(&#x27;&#x27;SHA1&#x27;&#x27;, SUBSTRING((SELECT TOP &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(<span class="variable">@MaxRows</span> <span class="keyword">AS</span> NVARCHAR(<span class="number">10</span>)) <span class="operator">+</span> <span class="string">&#x27; &#x27;</span> <span class="operator">+</span> <span class="variable">@PKColumns</span> <span class="operator">+</span> <span class="string">&#x27; FROM &#x27;</span> <span class="operator">+</span> QUOTENAME(<span class="variable">@SchemaName</span>) <span class="operator">+</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">+</span> QUOTENAME(<span class="variable">@TableName</span>) <span class="operator">+</span> <span class="string">&#x27; ORDER BY &#x27;</span> <span class="operator">+</span> <span class="variable">@PKColumns</span> <span class="operator">+</span> <span class="string">&#x27; FOR XML RAW, BINARY BASE64), 1, &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(<span class="variable">@DataSize</span> <span class="keyword">AS</span> NVARCHAR(<span class="number">10</span>)) <span class="operator">+</span> <span class="string">&#x27;)),</span></span><br><span class="line"><span class="string">                   &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(<span class="variable">@RecordCount</span> <span class="keyword">AS</span> NVARCHAR(<span class="number">20</span>)) <span class="operator">+</span> <span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                   1, NULL&#x27;</span>;</span><br><span class="line">        <span class="keyword">END</span></span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="comment">-- 無主鍵，使用所有欄位計算雜湊值</span></span><br><span class="line">            <span class="keyword">SET</span> <span class="variable">@SQL</span> <span class="operator">=</span> N<span class="string">&#x27;</span></span><br><span class="line"><span class="string">            INSERT INTO #TableHashes (SchemaName, TableName, TableHash, RecordCount, UsedPK, ErrorMessage)</span></span><br><span class="line"><span class="string">            SELECT &#x27;&#x27;&#x27;</span> <span class="operator">+</span> <span class="variable">@SchemaName</span> <span class="operator">+</span> <span class="string">&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;</span> <span class="operator">+</span> <span class="variable">@TableName</span> <span class="operator">+</span> <span class="string">&#x27;&#x27;&#x27;,</span></span><br><span class="line"><span class="string">                   HASHBYTES(&#x27;&#x27;SHA1&#x27;&#x27;, SUBSTRING((SELECT TOP &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(<span class="variable">@MaxRows</span> <span class="keyword">AS</span> NVARCHAR(<span class="number">10</span>)) <span class="operator">+</span> <span class="string">&#x27; * FROM &#x27;</span> <span class="operator">+</span> QUOTENAME(<span class="variable">@SchemaName</span>) <span class="operator">+</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">+</span> QUOTENAME(<span class="variable">@TableName</span>) <span class="operator">+</span> <span class="string">&#x27; FOR XML RAW, BINARY BASE64), 1, &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(<span class="variable">@DataSize</span> <span class="keyword">AS</span> NVARCHAR(<span class="number">10</span>)) <span class="operator">+</span> <span class="string">&#x27;)),</span></span><br><span class="line"><span class="string">                   &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(<span class="variable">@RecordCount</span> <span class="keyword">AS</span> NVARCHAR(<span class="number">20</span>)) <span class="operator">+</span> <span class="string">&#x27;,</span></span><br><span class="line"><span class="string">                   0, NULL&#x27;</span>;</span><br><span class="line">        <span class="keyword">END</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">BEGIN</span> TRY</span><br><span class="line">            <span class="keyword">EXEC</span> sp_executesql <span class="variable">@SQL</span>;</span><br><span class="line">        <span class="keyword">END</span> TRY</span><br><span class="line">        <span class="keyword">BEGIN</span> CATCH</span><br><span class="line">            PRINT <span class="string">&#x27;錯誤處理表格: &#x27;</span> <span class="operator">+</span> <span class="variable">@SchemaName</span> <span class="operator">+</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">+</span> <span class="variable">@TableName</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">-- 儲存錯誤資訊到表格</span></span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> #TableHashes (SchemaName, TableName, TableHash, RecordCount, UsedPK, ErrorMessage)</span><br><span class="line">            <span class="keyword">VALUES</span> (<span class="variable">@SchemaName</span>, <span class="variable">@TableName</span>, <span class="keyword">NULL</span>, <span class="variable">@RecordCount</span>, <span class="variable">@HasPK</span>, ERROR_MESSAGE());</span><br><span class="line">        <span class="keyword">END</span> CATCH</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> TableCursor <span class="keyword">INTO</span> <span class="variable">@SchemaName</span>, <span class="variable">@TableName</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CLOSE</span> TableCursor;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> TableCursor;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 顯示結果</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    SchemaName,</span><br><span class="line">    TableName,</span><br><span class="line">    <span class="keyword">CONVERT</span>(<span class="type">VARCHAR</span>(<span class="number">40</span>), TableHash, <span class="number">2</span>) <span class="keyword">AS</span> TableHashHex,</span><br><span class="line">    RecordCount,</span><br><span class="line">    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> UsedPK <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;Yes&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;No&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> UsedPrimaryKey,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> TableHash <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;Failed to calculate hash&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;Success&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> Status,</span><br><span class="line">    ErrorMessage</span><br><span class="line"><span class="keyword">FROM</span> #TableHashes</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> SchemaName, TableName;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清理暫存表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> #TableHashes;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 資料庫(MSSQL) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSSQL </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多執行緒的相關術語</title>
      <link href="/2025/02/16/%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92%E7%9A%84%E7%9B%B8%E9%97%9C%E8%A1%93%E8%AA%9E/"/>
      <url>/2025/02/16/%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92%E7%9A%84%E7%9B%B8%E9%97%9C%E8%A1%93%E8%AA%9E/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>序列（串行）</strong>：任務依照先後順序逐一執行，必須等前一個任務完成後，下一個任務才會開始執行。</li><li><strong>並發（交替執行）</strong>：多個任務在同一單位時間內交替執行，從宏觀上看似乎同時進行，但在任何特定時刻，實際上僅有一個任務在執行。這種模式通常發生在單核心或單執行緒環境下。</li><li><strong>平行（真正同時執行）</strong>：多個任務能夠在相同時刻真正地同時運行，這通常依賴於多核心處理器或多處理器系統，使得各任務可分派到不同的核心上同步執行。</li></ul><h2 id="1-序列（串行）"><a href="#1-序列（串行）" class="headerlink" title="1. 序列（串行）"></a><strong>1. 序列（串行）</strong></h2><p>所有任務按順序執行，一個完成後才開始下一個。</p><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a><strong>程式碼</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        task(<span class="string">&quot;Task 1&quot;</span>);</span><br><span class="line">        task(<span class="string">&quot;Task 2&quot;</span>);</span><br><span class="line">        task(<span class="string">&quot;Task 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Total time: &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; started&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模擬 1 秒執行時間</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="輸出"><a href="#輸出" class="headerlink" title="輸出"></a><strong>輸出</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task 1 started</span><br><span class="line">Task 1 finished</span><br><span class="line">Task 2 started</span><br><span class="line">Task 2 finished</span><br><span class="line">Task 3 started</span><br><span class="line">Task 3 finished</span><br><span class="line">Total time: 3000ms</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p><p>每個任務按順序執行，執行時間約 <code>3s</code>，因為它們是 <strong>串行（同步）</strong> 的。</p></blockquote><hr><h2 id="2-並發（交替執行）"><a href="#2-並發（交替執行）" class="headerlink" title="2. 並發（交替執行）"></a><strong>2. 並發（交替執行）</strong></h2><p>使用 <strong><code>ExecutorService</code> 和 <code>Future</code></strong> 來模擬 <strong>並發（但仍然是單執行緒交替運行）</strong>。</p><h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a><strong>程式碼</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>); <span class="comment">// 單一執行緒（模擬並發交替）</span></span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; task1 = executor.submit(() -&gt; task(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        Future&lt;?&gt; task2 = executor.submit(() -&gt; task(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">        Future&lt;?&gt; task3 = executor.submit(() -&gt; task(<span class="string">&quot;Task 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        task1.get();</span><br><span class="line">        task2.get();</span><br><span class="line">        task3.get();</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; started&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模擬 1 秒執行時間</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="輸出（但可能順序不同）"><a href="#輸出（但可能順序不同）" class="headerlink" title="輸出（但可能順序不同）"></a><strong>輸出</strong>（但可能順序不同）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task 1 started</span><br><span class="line">Task 1 finished</span><br><span class="line">Task 2 started</span><br><span class="line">Task 2 finished</span><br><span class="line">Task 3 started</span><br><span class="line">Task 3 finished</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p><p>這裡用 <strong>單一執行緒池（FixedThreadPool(1)）</strong>，所以雖然 <strong>任務是並發提交的</strong>，但仍然是 <strong>交替運行（不是並行）</strong>。</p></blockquote><hr><h2 id="3-平行（真正同時執行）"><a href="#3-平行（真正同時執行）" class="headerlink" title="3. 平行（真正同時執行）"></a><strong>3. 平行（真正同時執行）</strong></h2><p>使用 <strong>多執行緒（<code>ExecutorService</code> 的 <code>FixedThreadPool</code>）</strong> 來模擬 <strong>真正的並行運行</strong>。</p><h3 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a><strong>程式碼</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParallelExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 3 個執行緒同時執行</span></span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; task(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; task(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; task(<span class="string">&quot;Task 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; started on &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模擬 1 秒執行時間</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; finished on &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="輸出（順序可能不同）"><a href="#輸出（順序可能不同）" class="headerlink" title="輸出（順序可能不同）"></a><strong>輸出</strong>（順序可能不同）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task 1 started on pool-1-thread-1</span><br><span class="line">Task 2 started on pool-1-thread-2</span><br><span class="line">Task 3 started on pool-1-thread-3</span><br><span class="line">Task 1 finished on pool-1-thread-1</span><br><span class="line">Task 2 finished on pool-1-thread-2</span><br><span class="line">Task 3 finished on pool-1-thread-3</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p><p>這次我們用了 <strong>3 個執行緒</strong>，所以任務 <strong>真正同時執行（並行）</strong>，總執行時間約 <strong>1 秒</strong>，比起並發或串行方式快了 <strong>3 倍</strong>。</p></blockquote><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a><strong>總結</strong></h2><table><thead><tr><th>類型</th><th>方式</th><th>特性</th><th>例子</th></tr></thead><tbody><tr><td><strong>序列（串行）</strong></td><td>單執行緒，順序執行</td><td>需要等前一個完成才能開始下一個</td><td><code>main()</code> 內部依序呼叫 <code>task()</code></td></tr><tr><td><strong>並發（交替執行）</strong></td><td>多任務交替運行，但仍是單執行緒</td><td>交替執行，非真正同時進行</td><td><code>ExecutorService.newFixedThreadPool(1)</code></td></tr><tr><td><strong>平行（真正同時執行）</strong></td><td>多個執行緒同時執行</td><td>需要多核心 CPU，真正並行</td><td><code>ExecutorService.newFixedThreadPool(3)</code></td></tr></tbody></table><hr><h2 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h2><ul><li><strong>序列（串行）</strong>：適合簡單任務，沒有同步問題，但效能較低。</li><li><strong>並發（交替執行）</strong>：適合 <strong>I&#x2F;O 密集型</strong> 任務，例如網路請求、檔案讀寫，因為大部分時間花在等待。</li><li><strong>平行（真正同時執行）</strong>：適合 <strong>CPU 密集型</strong> 任務，例如影像處理、數據計算，充分利用多核心 CPU。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MultiThread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看MSSQL資料庫的佔用空間</title>
      <link href="/2025/02/02/%E6%9F%A5%E7%9C%8BMSSQL%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E4%BD%94%E7%94%A8%E7%A9%BA%E9%96%93/"/>
      <url>/2025/02/02/%E6%9F%A5%E7%9C%8BMSSQL%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E4%BD%94%E7%94%A8%E7%A9%BA%E9%96%93/</url>
      
        <content type="html"><![CDATA[<p>在 MSSQL 中，可以通過系統檢視或內建存儲過程來查看資料庫的大小，包括資料和索引的占用。以下是常用的方法：</p><hr><h3 id="方法-1：使用-sp-spaceused"><a href="#方法-1：使用-sp-spaceused" class="headerlink" title="方法 1：使用 sp_spaceused"></a><strong>方法 1：使用 <code>sp_spaceused</code></strong></h3><p><code>sp_spaceused</code> 是一個內建的存儲過程，用於查看資料庫的空間使用情況。</p><h3 id="查看整個資料庫的大小"><a href="#查看整個資料庫的大小" class="headerlink" title="查看整個資料庫的大小"></a><strong>查看整個資料庫的大小</strong></h3><ol><li><p>切換到目標資料庫：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE [YourDatabaseName];</span><br><span class="line">GO</span><br></pre></td></tr></table></figure></li><li><p>執行以下命令：返回的關鍵結果：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_spaceused;</span><br></pre></td></tr></table></figure><ul><li><code>database_size</code>：資料庫的總大小（資料和索引）。</li><li><code>unallocated space</code>：未分配的空間。</li></ul></li></ol><h3 id="查看特定表的大小"><a href="#查看特定表的大小" class="headerlink" title="查看特定表的大小"></a><strong>查看特定表的大小</strong></h3><ol><li><p>執行以下命令：返回的關鍵結果：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_spaceused N<span class="string">&#x27;[YourTableName]&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>reserved</code>：表的總預留空間（資料、索引和未使用空間）。</li><li><code>data</code>：表中資料的大小。</li><li><code>index_size</code>：表的索引大小。</li><li><code>unused</code>：未使用的空間。</li></ul></li></ol><hr><h3 id="方法-2：使用-sys-master-files-和-sys-database-files"><a href="#方法-2：使用-sys-master-files-和-sys-database-files" class="headerlink" title="方法 2：使用 sys.master_files 和 sys.database_files"></a><strong>方法 2：使用 <code>sys.master_files</code> 和 <code>sys.database_files</code></strong></h3><p>可以直接從系統檢視中查詢資料庫文件的大小。</p><h3 id="查看資料庫的總大小"><a href="#查看資料庫的總大小" class="headerlink" title="查看資料庫的總大小"></a><strong>查看資料庫的總大小</strong></h3><p>執行以下查詢：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name <span class="keyword">AS</span> DatabaseName,</span><br><span class="line">    <span class="built_in">SUM</span>(size) <span class="operator">*</span> <span class="number">8</span> <span class="operator">/</span> <span class="number">1024</span> <span class="keyword">AS</span> SizeInMB</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sys.master_files</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    database_id <span class="operator">=</span> DB_ID(<span class="string">&#x27;YourDatabaseName&#x27;</span>) <span class="comment">-- 替換為資料庫名稱</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    name;</span><br></pre></td></tr></table></figure><ul><li><code>size</code>：每個文件的大小（以 8KB 頁為單位）。</li></ul><hr><h3 id="方法-3：使用-sys-dm-db-partition-stats"><a href="#方法-3：使用-sys-dm-db-partition-stats" class="headerlink" title="方法 3：使用 sys.dm_db_partition_stats"></a><strong>方法 3：使用 <code>sys.dm_db_partition_stats</code></strong></h3><p>這個動態管理檢視用於查看每個表和索引的空間使用情況。</p><h3 id="查看所有表的大小"><a href="#查看所有表的大小" class="headerlink" title="查看所有表的大小"></a><strong>查看所有表的大小</strong></h3><p>執行以下查詢：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t.NAME <span class="keyword">AS</span> TableName,</span><br><span class="line">    <span class="built_in">SUM</span>(a.total_pages) <span class="operator">*</span> <span class="number">8</span> <span class="keyword">AS</span> TotalSpaceKB,</span><br><span class="line">    <span class="built_in">SUM</span>(a.used_pages) <span class="operator">*</span> <span class="number">8</span> <span class="keyword">AS</span> UsedSpaceKB,</span><br><span class="line">    (<span class="built_in">SUM</span>(a.total_pages) <span class="operator">-</span> <span class="built_in">SUM</span>(a.used_pages)) <span class="operator">*</span> <span class="number">8</span> <span class="keyword">AS</span> UnusedSpaceKB</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sys.tables t</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    sys.indexes i <span class="keyword">ON</span> t.OBJECT_ID <span class="operator">=</span> i.object_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    sys.partitions p <span class="keyword">ON</span> i.object_id <span class="operator">=</span> p.OBJECT_ID <span class="keyword">AND</span> i.index_id <span class="operator">=</span> p.index_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    sys.allocation_units a <span class="keyword">ON</span> p.partition_id <span class="operator">=</span> a.container_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    TotalSpaceKB <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><ul><li><code>TotalSpaceKB</code>：表的總大小（包括資料和索引）。</li><li><code>UsedSpaceKB</code>：已使用的空間。</li><li><code>UnusedSpaceKB</code>：未使用的空間。</li></ul><hr><h3 id="方法-4：使用-sys-database-files-查看具體文件大小"><a href="#方法-4：使用-sys-database-files-查看具體文件大小" class="headerlink" title="方法 4：使用 sys.database_files 查看具體文件大小"></a><strong>方法 4：使用 <code>sys.database_files</code> 查看具體文件大小</strong></h3><p>執行以下查詢來查看資料庫中每個文件的大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name <span class="keyword">AS</span> FileName,</span><br><span class="line">    size <span class="operator">*</span> <span class="number">8</span> <span class="operator">/</span> <span class="number">1024</span> <span class="keyword">AS</span> SizeInMB,</span><br><span class="line">    physical_name <span class="keyword">AS</span> PhysicalPath,</span><br><span class="line">    type_desc <span class="keyword">AS</span> FileType</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sys.database_files;</span><br></pre></td></tr></table></figure><ul><li><code>FileType</code>：文件類型（<code>ROWS</code> 表示資料文件，<code>LOG</code> 表示日誌文件）。</li><li><code>SizeInMB</code>：文件大小（以 MB 為單位）。</li></ul><hr><h3 id="推薦方法"><a href="#推薦方法" class="headerlink" title="推薦方法"></a><strong>推薦方法</strong></h3><ul><li><strong>快速檢查資料庫大小：</strong> 使用 <code>sp_spaceused</code>。</li><li><strong>詳細查看所有表大小：</strong> 使用 <code>sys.dm_db_partition_stats</code>。</li><li><strong>檢查文件大小：</strong> 使用 <code>sys.database_files</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 資料庫(MSSQL) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSSQL </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分散式系統的CAP定理(CAP theorem)</title>
      <link href="/2024/09/21/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1%E7%9A%84CAP%E5%AE%9A%E7%90%86-CAP-theorem/"/>
      <url>/2024/09/21/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1%E7%9A%84CAP%E5%AE%9A%E7%90%86-CAP-theorem/</url>
      
        <content type="html"><![CDATA[<p>在設計分散式系統(Distributed System)前，必須要了解CAP定理(CAP theorem)，又稱布魯爾定理（Brewer’s theorem）。</p><p>CAP定理的三個字母C，A，P分別代表以下：</p><ul><li><strong>C</strong>onsistency：一致性</li><li><strong>A</strong>vailability：可用性</li><li><strong>P</strong>artition-tolerance：分區容錯</li></ul><h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>指分散式系統中的每個節點(nodes)所查到的都是一致且最新的資料。</p><h3 id="Availability-可用性"><a href="#Availability-可用性" class="headerlink" title="Availability 可用性"></a>Availability 可用性</h3><p>在任何時候，每次向系統發出請求都能在合理的時間內獲得回應，但並不保證回應的資料為最新。</p><h3 id="Partition-tolerance-分區容錯"><a href="#Partition-tolerance-分區容錯" class="headerlink" title="Partition-tolerance 分區容錯"></a>Partition-tolerance 分區容錯</h3><p>當網路或節點故障造成系統的不同網路分區間(Partitions)的傳輸資料丟失時，系統仍可以正常運作。</p><p>滿足以上三種特性是一個完美的分散式系統欲達成的目標。</p><p>不過CAP定理指出，一個分散式系統最多只能滿足以上三個特性中的兩個，而無法同時滿足三個。</p><blockquote><p>You can have at most two of these properties for any shared-data system</p></blockquote><p>因此在設計分散式系統時，只能從三個特性中取捨，最多只能選擇兩點來滿足，有下列組合：</p><ul><li>CP (Consistency and Partition Tolerant)：一致性與分區容錯。</li><li>AP (Availability and Partition Tolerant)：可用性與分區容錯。</li><li>CA (Consistency and Availability)： 一致性與可用性。</li></ul><h3 id="CP-Consistent-and-Partition-Tolerant"><a href="#CP-Consistent-and-Partition-Tolerant" class="headerlink" title="CP (Consistent and Partition Tolerant)"></a>CP (Consistent and Partition Tolerant)</h3><blockquote><p>在分區容錯的情況下保證資料的一致性，那就必須犧牲可用性。</p></blockquote><h3 id="AP-Availability-and-Partition-Tolerant"><a href="#AP-Availability-and-Partition-Tolerant" class="headerlink" title="AP (Availability and Partition Tolerant)"></a>AP (Availability and Partition Tolerant)</h3><blockquote><p>在分區容錯的情況下保證系統的可用性，那就必須犧牲資料的一致性。</p></blockquote><h3 id="CA-Consistent-and-Availability"><a href="#CA-Consistent-and-Availability" class="headerlink" title="CA (Consistent and Availability)"></a>CA (Consistent and Availability)</h3><blockquote><p>保證系統的可用性與資料一致，那就無法有分區容錯，也就是只有一個節點，這樣的情況就不是分散式系統了，不過這樣的系統可能並不存在。</p></blockquote><p>CAP定理的證明請參考<a href="https://strrl.dev/post/before-2022/brewers-conjecture-and-the-feasibility-of-consistent-available-partition-tolerant-web-services">Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</a>。</p><p>而分散式系統本身即為滿足分區容錯(P)的架構，也就是希望系統在部分節點或網路失靈的狀況下功能能可正常運作，因此通常是在CP與AP中作抉擇。</p>]]></content>
      
      
      <categories>
          
          <category> 名詞解釋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分散式(Distributed) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate → @DiscriminatorColumn說明</title>
      <link href="/2024/05/17/Hibernate-DiscriminatorColumn%E8%AA%AA%E6%98%8E/"/>
      <url>/2024/05/17/Hibernate-DiscriminatorColumn%E8%AA%AA%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><code>@DiscriminatorColumn</code> 註解用於在 JPA 繼承結構中，為單表策略 (<code>InheritanceType.SINGLE_TABLE</code>) 的繼承層次結構指定區分列。這樣，JPA 可以使用這個列來識別每一行對應的具體實體類型。</p><p>讓我們詳細解釋一下：</p><h3 id="註解部分"><a href="#註解部分" class="headerlink" title="註解部分"></a>註解部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;accountType&quot;, discriminatorType = DiscriminatorType.STRING)</span></span><br></pre></td></tr></table></figure><ul><li><code>@DiscriminatorColumn</code>：這個註解指定了用來區分不同實體類型的列。</li><li><code>name=&quot;accountType&quot;</code>：這指定了區分列的名稱為 <code>accountType</code>。這個列將會被添加到生成的單表中，用來存儲每一行對應的實體類型。</li><li><code>discriminatorType = DiscriminatorType.STRING</code>：這指定了區分列的類型為 <code>STRING</code>。區分列可以是 <code>STRING</code>、<code>CHAR</code> 或 <code>INTEGER</code>。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>當使用 <code>InheritanceType.SINGLE_TABLE</code> 繼承策略時，所有的繼承層次結構中的實體類型都會被映射到同一張表中。區分列 (<code>discriminator column</code>) 用來區分表中的每一行對應哪個具體的實體類型。例如，如果有一個 <code>AdminGroup</code> 基本類和兩個子類 <code>AdminUser</code> 和 <code>AdminManager</code>，這張表中的每一行會有一個 <code>accountType</code> 列來指示該行是 <code>AdminUser</code> 還是 <code>AdminManager</code>。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假設我們有以下實體類：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;accountType&quot;, discriminatorType = DiscriminatorType.STRING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminGroup</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;USER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminUser</span> <span class="keyword">extends</span> <span class="title class_">AdminGroup</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userSpecificField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;MANAGER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminManager</span> <span class="keyword">extends</span> <span class="title class_">AdminGroup</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String managerSpecificField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>對應的資料庫表可能如下：</p><table><thead><tr><th>id</th><th>name</th><th>accountType</th><th>userSpecificField</th><th>managerSpecificField</th></tr></thead><tbody><tr><td>1</td><td>AdminUser1</td><td>USER</td><td>someUserValue</td><td>NULL</td></tr><tr><td>2</td><td>AdminManager1</td><td>MANAGER</td><td>NULL</td><td>someManagerValue</td></tr></tbody></table><p>在這個表中，<code>accountType</code> 列用來區分每一行是 <code>AdminUser</code> 還是 <code>AdminManager</code>。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p><code>@DiscriminatorColumn</code> 註解告訴 JPA 在單表策略的繼承結構中，使用 <code>accountType</code> 列來區分不同的實體類型，並且這個列的類型是 <code>STRING</code>。這樣，JPA 就可以正確地將表中的每一行映射到相應的實體類。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap → computeIfAbsent()</title>
      <link href="/2024/03/21/HashMap-%E2%86%92-computeIfAbsent/"/>
      <url>/2024/03/21/HashMap-%E2%86%92-computeIfAbsent/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 當key不存在，就執行第二個參數的函數，並回傳執行後的值，然後也會put</span></span><br><span class="line"><span class="comment">// 如果函數返回 null，則不會put</span></span><br><span class="line"><span class="comment">// 如果函數本身拋出（未經檢查的）異常，則重新拋出異常，則不會put</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; stringLength = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stringLength.put(<span class="string">&quot;John&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stringLength.computeIfAbsent(<span class="string">&quot;John&quot;</span>, String::length);</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    System.out.println(<span class="string">&quot;stringLength = &quot;</span> + stringLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段程式碼看起來沒有明顯的錯誤，但可以做一些優化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    List&lt;FileTempRecord&gt; fileTempRecords = SSE_NOTIFY_IMAP.get(record.getCreatedBy());</span><br><span class="line">    <span class="keyword">if</span> (fileTempRecords == <span class="literal">null</span> || fileTempRecords.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        fileTempRecords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fileTempRecords.add(record);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fileTempRecords.add(record);</span><br><span class="line">    &#125;</span><br><span class="line">    SSE_NOTIFY_IMAP.put(record.getCreatedBy(), fileTempRecords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-computeIfAbsent-方法"><a href="#使用-computeIfAbsent-方法" class="headerlink" title="使用 computeIfAbsent() 方法"></a>使用 computeIfAbsent() 方法</h3><p>現在的程式碼需要先檢查一下 map 中是否有對應的 List，如果沒有的話就要建立一個新的 List。這個過程可以使用 computeIfAbsent() 方法來簡化，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    SSE_NOTIFY_IMAP.computeIfAbsent(record.getCreatedBy(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣，如果 SSE_NOTIFY_IMAP 中沒有對應的 List，computeIfAbsent() 方法會自動建立一個新的 ArrayList，並將 record 新增到 List 中。</p><h3 id="使用-Collection-addAll"><a href="#使用-Collection-addAll" class="headerlink" title="使用 Collection#addAll()"></a>使用 Collection#addAll()</h3><p>在原始程式碼中，如果 SSE_NOTIFY_IMAP 中已經有對應的 List，就需要分別使用 add() 方法來新增 record。實際上，我們可以使用 Collection#addAll() 方法來將一個集合中的所有元素新增到另一個集合中，這樣可以更簡潔的實現新增動作，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    List&lt;FileTempRecord&gt; fileTempRecords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fileTempRecords.add(record);</span><br><span class="line">    SSE_NOTIFY_IMAP.computeIfAbsent(record.getCreatedBy(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).addAll(fileTempRecords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣，如果 SSE_NOTIFY_IMAP 中已經有對應的 List，就會將 fileTempRecords 中的元素全部加到該 List 中。</p><p>綜上所述，我們可以使用下面的程式碼來優化原始程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    SSE_NOTIFY_IMAP.computeIfAbsent(record.getCreatedBy(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap → putIfAbsent()</title>
      <link href="/2024/03/20/HashMap-%E2%86%92-putIfAbsent/"/>
      <url>/2024/03/20/HashMap-%E2%86%92-putIfAbsent/</url>
      
        <content type="html"><![CDATA[<p>putIfAbsent() 是 HashMap 在 Java 中的一個實用方法，它屬於 Map 介面。這個方法用來在對應的鍵（key）不存在於映射中時，將一組key,value 放入映射(map)裡。如果映射先前已包含該鍵(key)的映射，則不做任何更動。putIfAbsent() 方法既可以確保不會不小心覆蓋已有的鍵值(key, value)，也可以用來在多執行緒環境下安全的更新map，假設映射本身是同步的或者是一個 ConcurrentHashMap。</p><p>方法簽名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span></span><br></pre></td></tr></table></figure><p>K: 鍵的類型</p><p>V: 值的類型</p><p>返回值：如果映射中已經有這個鍵，則返回鍵對應的舊值；如果沒有，則返回 null（並且將新的鍵值對插入映射）。</p><h3 id="範例1"><a href="#範例1" class="headerlink" title="範例1"></a>範例1</h3><p>以下是使用 putIfAbsent() 方法的一個簡單範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PutIfAbsentExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 建立一個 HashMap</span></span><br><span class="line">        Map&lt;String, Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向映射中新增一些資料</span></span><br><span class="line">        scores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        scores.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 putIfAbsent() 嘗試新增一個新的key,value</span></span><br><span class="line">        <span class="comment">// 由於 &quot;Alice&quot; 已存在，所以這個操作不會更改映射</span></span><br><span class="line">        scores.putIfAbsent(<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 嘗試新增資料，因為 &quot;Charlie&quot; 不存在，所以會被成功新增</span></span><br><span class="line">        scores.putIfAbsent(<span class="string">&quot;Charlie&quot;</span>, <span class="number">85</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 輸出map的內容</span></span><br><span class="line">        scores.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="範例2"><a href="#範例2" class="headerlink" title="範例2"></a>範例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// new HashMap</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增3個值</span></span><br><span class="line">        sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sites HashMap: &quot;</span> + sites);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增一個不存在的key，不存在就新增，普通put也一樣效果</span></span><br><span class="line">        sites.putIfAbsent(<span class="number">4</span>, <span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增一個存在的key，這裡如果是普通的put，那key2會被覆蓋，如果使用此方法則不會被覆蓋</span></span><br><span class="line">        sites.putIfAbsent(<span class="number">2</span>, <span class="string">&quot;Wiki&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Updated Languages: &quot;</span> + sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-Script 屬性</title>
      <link href="/2024/02/05/HTML-Scrpit-%E5%B1%AC%E6%80%A7/"/>
      <url>/2024/02/05/HTML-Scrpit-%E5%B1%AC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="src屬性"><a href="#src屬性" class="headerlink" title="src屬性"></a>src屬性</h2><p>src 屬性指定外部腳本的 URL，允許開發者將 JavaScript 程式碼組織在單獨檔案中，而非直接寫在 HTML 內。當<code>&lt;script&gt;</code>標籤包含src屬性時，不應包含嵌入式腳本程式碼。</p><h2 id="type屬性"><a href="#type屬性" class="headerlink" title="type屬性"></a>type屬性</h2><p>type 屬性聲明腳本的 MIME 類型 (現已非必需，因為現代瀏覽器預設使用JavaScript)。早期 HTML 規範中，這個屬性用來指示腳本語言的類型，如”<code>text/javascript</code>“ 或 “<code>application/javascript</code>“。</p><h2 id="async屬性"><a href="#async屬性" class="headerlink" title="async屬性"></a>async屬性</h2><p>async 屬性是個布林屬性，告訴瀏覽器非同步的載入檔案。這意味著腳本會在下載完畢後儘快執行，但不會阻塞 HTML 文件的解析。此屬性僅適用於帶有src屬性的<code>&lt;script&gt;</code>標籤。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;xxx/script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br></pre></td></tr></table></figure><h2 id="defer屬性"><a href="#defer屬性" class="headerlink" title="defer屬性"></a>defer屬性</h2><p>與async屬性類似，defer屬性也會指示瀏覽器非同步載入腳本，但有個關鍵不同：帶有 <code>defer</code> 屬性的腳本保證會在文件解析完成後、DOMContentLoaded事件觸發前，按照它們在檔案中出現的順序執行。這也僅適用於帶有src屬性的腳本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;xxx/script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/pw/ABLVV84LFnpNsdPgLjmE_CLpESaZqTb9sD7TZZL4emfhvxPNJk1LJarVlUoyuzQQ6cwyBF-aDnfwtf68wwGfZge7ZE2VriXEFNZXE1RgkSW2Ym_1DTaCNuk=w800" alt="時序圖"><br> (圖片來源：<a href="https://medium.com/@nikjohn/speed-up-google-maps-and-everything-else-with-async-defer-7b9814efb2b">Speed up Google Maps(and everything else) with async &amp; defer</a>)</p><h2 id="crossorigin屬性"><a href="#crossorigin屬性" class="headerlink" title="crossorigin屬性"></a>crossorigin屬性</h2><p><code>crossorigin</code> 屬性用於設定與跨源資源共享 (CORS) 相關設定。對於從CDN等不同來源載入的腳本特別重要。它可設為”<code>anonymous</code>“(不會發送用戶憑證) 或 “<code>use-credentials</code>“ (會發送使用者憑證)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.example.com/library.js&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="integrity屬性"><a href="#integrity屬性" class="headerlink" title="integrity屬性"></a>integrity屬性</h2><p><code>integrity</code> 屬性提供了一種安全特性，允許瀏覽器驗證取得的資源是否未經篡改。透過與腳本匹配的Hash值 (如SHA-256) 來確保腳本的完整性。<br>當瀏覽器載入帶有 <code>integrity</code> 屬性的資源時，它會計算從網絡上取得的文件的Hash值，並與<code>integrity</code>屬性中指定的Hash值進行比對：<br>如果兩個Hash值相同，則認為這個檔案是安全的，未被篡改，瀏覽器將正常載入和執行該檔案。<br>如果Hash值不同，則表示檔案可能在傳輸過程中被篡改，瀏覽器會拒絕載入該文件，以保護 Client 免受潛在的安全風險。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.example.com/library.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-Hash值&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-MySql</title>
      <link href="/2024/01/27/Docker-MySql/"/>
      <url>/2024/01/27/Docker-MySql/</url>
      
        <content type="html"><![CDATA[<p>新增檔案將內容貼上後，將檔案命名為<code>docker-compose.yml</code>，再執行<code>docker-compose up -d</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">linux/amd64</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=sample</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=demouser</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=e23s5</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volumes:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./conf.d/mysql.cnf:/etc/mysql/conf.d/mysql.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./init.d:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_cheng</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;23506:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">pj_network:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">pj_network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-Solr Compose</title>
      <link href="/2024/01/12/Docker-Solr-Compose/"/>
      <url>/2024/01/12/Docker-Solr-Compose/</url>
      
        <content type="html"><![CDATA[<p>本機開發時會用到，遇到要升級時需要測試環境，所以本機使用 Docker 建立 Solr6，然後在 VM 上建立 Solr8</p><h2 id="Solr-6"><a href="#Solr-6" class="headerlink" title="Solr 6"></a>Solr 6</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.7</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2181:2181&quot;</span></span><br><span class="line">  <span class="attr">solr:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">solr:6.6.3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8983:8983&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data:/var/solr</span></span><br><span class="line">      <span class="comment">#- ./init-solr.sh:/docker-entrypoint-initdb.d/init-solr.sh</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZK_HOST=zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SOLR_HOST=127.0.0.1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JETTY_PORT=8983</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">solr-foreground</span></span><br><span class="line">    <span class="comment">#command: [&quot;sh&quot;, &quot;/docker-entrypoint-initdb.d/init-solr.sh&quot;]</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>將文件存檔為 <code>docker-compose.yml</code> ，開啟終端機並且移動到該檔案的同一層目錄，執行指令 <code>docker-compose up -d</code> 服務啟動後，進入到容器 <code>docker exec -it solr-solr-1 bash</code> 執行指令建立 <code>Collection</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/opt/solr/bin/solr create_collection -d /opt/solr/server/solr/configsets/basic_configs -c line -shards 1 -replicationFactor 1</span><br><span class="line"></span><br><span class="line">/opt/solr/bin/solr create_collection -d /opt/solr/server/solr/configsets/basic_configs -c apilog -shards 1 -replicationFactor 1</span><br></pre></td></tr></table></figure><h2 id="Solr-8"><a href="#Solr-8" class="headerlink" title="Solr 8"></a>Solr 8</h2><p>此安裝的作業系統為 <code>CentOS 8</code>，下載 Solr 8.11.2 <a href="https://dlcdn.apache.org/lucene/solr/8.11.2">https://dlcdn.apache.org/lucene/solr/8.11.2</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlcdn.apache.org/lucene/solr/8.11.2/solr-8.11.2.zip</span><br></pre></td></tr></table></figure><p>解壓縮目錄</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip solr-8.11.2.zip</span><br></pre></td></tr></table></figure><p>進入 <code>solr-8.11.2/bin</code> 目錄，啟動 <code>Cloud</code> 指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr start -e cloud -force</span><br></pre></td></tr></table></figure><p>要注意防火牆要開通8983(solr), 9983(zk)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8983/tcp --permanent</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9983/tcp --permanent</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell-取得上一個月的事件錯誤記錄</title>
      <link href="/2024/01/05/PowerShell-%E5%8F%96%E5%BE%97%E4%B8%8A%E4%B8%80%E5%80%8B%E6%9C%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%8C%AF%E8%AA%A4%E8%A8%98%E9%8C%84/"/>
      <url>/2024/01/05/PowerShell-%E5%8F%96%E5%BE%97%E4%B8%8A%E4%B8%80%E5%80%8B%E6%9C%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%8C%AF%E8%AA%A4%E8%A8%98%E9%8C%84/</url>
      
        <content type="html"><![CDATA[<p>最近要將每月的報告自動化，所以使用PowerShell來取得一些記錄，要取得的記錄是事件檢視器前一個月的「應用程式」、「安全性」、「系統」各個的錯誤事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">month = Get-Date -Format <span class="string">&#x27;MM&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">year = Get-Date -Format <span class="string">&#x27;yyyy&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">dir</span> = <span class="string">&#x27;EventLog&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">if($</span><span class="language-bash">month -eq 1)&#123;</span></span><br><span class="line">    $year = $year-1</span><br><span class="line">    $month = 12</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $month = $month-1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">last = [DateTime]::DaysInMonth(<span class="variable">$year</span>, <span class="variable">$month</span>)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">first = Get-Date -Day 1 -Month <span class="variable">$month</span> -Year <span class="variable">$year</span> -Hour 0 -Minute 0 -Second 0</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">last = Get-Date -Day <span class="variable">$last</span> -Month <span class="variable">$month</span> -Year <span class="variable">$year</span> -Hour 23 -Minute 59 -Second 59</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">hostIP = ([System.Net.DNS]::GetHostAddresses(<span class="variable">$env</span>:COMPUTERNAME) |Where-Object &#123;<span class="variable">$_</span>.AddressFamily -eq <span class="string">&quot;InterNetwork&quot;</span>&#125; | select-object IPAddressToString)[0].IPAddressToString</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">events=@(<span class="string">&#x27;Application&#x27;</span>,<span class="string">&#x27;System&#x27;</span>,<span class="string">&#x27;Security&#x27;</span>)</span></span><br><span class="line"> </span><br><span class="line">Function EventLogger($message)&#123;</span><br><span class="line">    $nowTime = get-date -Format &#x27;yyyy-MM-dd HH:mm:ss&#x27;</span><br><span class="line">    Write-Output $nowTime $message &gt;&gt; $env:USERPROFILE\EventLog.log</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">try&#123;</span><br><span class="line">    Foreach($eventName in $events)&#123;</span><br><span class="line">        switch($eventName)&#123;</span><br><span class="line">            &quot;Security&quot; &#123;</span><br><span class="line">               $info = Get-EventLog Security | Where-Object &#123;$_.TimeGenerated -ge $first -and $_.TimeGenerated -le $last&#125; | Where-Object &#123;$_.EntryType -eq &#x27;FailureAudit&#x27;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">            Default &#123;</span><br><span class="line">               $info = Get-WinEvent -FilterHashtable @&#123;</span><br><span class="line">                   LogName=$eventName;</span><br><span class="line">                   Level=1,2;</span><br><span class="line">                   StartTime=$first;</span><br><span class="line">                   EndTime=$last;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if($info.Count -ne 0)&#123;</span><br><span class="line">            $info | Export-Csv -Path $env:USERPROFILE\$env:COMPUTERNAME-$hostIP-Log-$year$month-$eventName.csv -Encoding &quot;UTF8&quot;         </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            EventLogger $eventName&#x27; no event records&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        EventLogger $eventName&#x27; scan end&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch&#123;</span><br><span class="line">    EventLogger $Error[0].Exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
