<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多執行緒的相關術語</title>
      <link href="/2025/02/16/%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92%E7%9A%84%E7%9B%B8%E9%97%9C%E8%A1%93%E8%AA%9E/"/>
      <url>/2025/02/16/%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92%E7%9A%84%E7%9B%B8%E9%97%9C%E8%A1%93%E8%AA%9E/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>序列（串行）</strong>：任務依照先後順序逐一執行，必須等前一個任務完成後，下一個任務才會開始執行。</li><li><strong>並發（交替執行）</strong>：多個任務在同一單位時間內交替執行，從宏觀上看似乎同時進行，但在任何特定時刻，實際上僅有一個任務在執行。這種模式通常發生在單核心或單執行緒環境下。</li><li><strong>平行（真正同時執行）</strong>：多個任務能夠在相同時刻真正地同時運行，這通常依賴於多核心處理器或多處理器系統，使得各任務可分派到不同的核心上同步執行。</li></ul><h2 id="1-序列（串行）"><a href="#1-序列（串行）" class="headerlink" title="1. 序列（串行）"></a><strong>1. 序列（串行）</strong></h2><p>所有任務按順序執行，一個完成後才開始下一個。</p><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a><strong>程式碼</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        task(<span class="string">&quot;Task 1&quot;</span>);</span><br><span class="line">        task(<span class="string">&quot;Task 2&quot;</span>);</span><br><span class="line">        task(<span class="string">&quot;Task 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Total time: &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; started&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模擬 1 秒執行時間</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="輸出"><a href="#輸出" class="headerlink" title="輸出"></a><strong>輸出</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task 1 started</span><br><span class="line">Task 1 finished</span><br><span class="line">Task 2 started</span><br><span class="line">Task 2 finished</span><br><span class="line">Task 3 started</span><br><span class="line">Task 3 finished</span><br><span class="line">Total time: 3000ms</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p><p>每個任務按順序執行，執行時間約 <code>3s</code>，因為它們是 <strong>串行（同步）</strong> 的。</p></blockquote><hr><h2 id="2-並發（交替執行）"><a href="#2-並發（交替執行）" class="headerlink" title="2. 並發（交替執行）"></a><strong>2. 並發（交替執行）</strong></h2><p>使用 <strong><code>ExecutorService</code> 和 <code>Future</code></strong> 來模擬 <strong>並發（但仍然是單執行緒交替運行）</strong>。</p><h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a><strong>程式碼</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>); <span class="comment">// 單一執行緒（模擬並發交替）</span></span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; task1 = executor.submit(() -&gt; task(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        Future&lt;?&gt; task2 = executor.submit(() -&gt; task(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">        Future&lt;?&gt; task3 = executor.submit(() -&gt; task(<span class="string">&quot;Task 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        task1.get();</span><br><span class="line">        task2.get();</span><br><span class="line">        task3.get();</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; started&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模擬 1 秒執行時間</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="輸出（但可能順序不同）"><a href="#輸出（但可能順序不同）" class="headerlink" title="輸出（但可能順序不同）"></a><strong>輸出</strong>（但可能順序不同）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task 1 started</span><br><span class="line">Task 1 finished</span><br><span class="line">Task 2 started</span><br><span class="line">Task 2 finished</span><br><span class="line">Task 3 started</span><br><span class="line">Task 3 finished</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p><p>這裡用 <strong>單一執行緒池（FixedThreadPool(1)）</strong>，所以雖然 <strong>任務是並發提交的</strong>，但仍然是 <strong>交替運行（不是並行）</strong>。</p></blockquote><hr><h2 id="3-平行（真正同時執行）"><a href="#3-平行（真正同時執行）" class="headerlink" title="3. 平行（真正同時執行）"></a><strong>3. 平行（真正同時執行）</strong></h2><p>使用 <strong>多執行緒（<code>ExecutorService</code> 的 <code>FixedThreadPool</code>）</strong> 來模擬 <strong>真正的並行運行</strong>。</p><h3 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a><strong>程式碼</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParallelExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 3 個執行緒同時執行</span></span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; task(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; task(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">        executor.execute(() -&gt; task(<span class="string">&quot;Task 3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; started on &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模擬 1 秒執行時間</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; finished on &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="輸出（順序可能不同）"><a href="#輸出（順序可能不同）" class="headerlink" title="輸出（順序可能不同）"></a><strong>輸出</strong>（順序可能不同）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task 1 started on pool-1-thread-1</span><br><span class="line">Task 2 started on pool-1-thread-2</span><br><span class="line">Task 3 started on pool-1-thread-3</span><br><span class="line">Task 1 finished on pool-1-thread-1</span><br><span class="line">Task 2 finished on pool-1-thread-2</span><br><span class="line">Task 3 finished on pool-1-thread-3</span><br></pre></td></tr></table></figure><blockquote><p>分析：</p><p>這次我們用了 <strong>3 個執行緒</strong>，所以任務 <strong>真正同時執行（並行）</strong>，總執行時間約 <strong>1 秒</strong>，比起並發或串行方式快了 <strong>3 倍</strong>。</p></blockquote><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a><strong>總結</strong></h2><table><thead><tr><th>類型</th><th>方式</th><th>特性</th><th>例子</th></tr></thead><tbody><tr><td><strong>序列（串行）</strong></td><td>單執行緒，順序執行</td><td>需要等前一個完成才能開始下一個</td><td><code>main()</code> 內部依序呼叫 <code>task()</code></td></tr><tr><td><strong>並發（交替執行）</strong></td><td>多任務交替運行，但仍是單執行緒</td><td>交替執行，非真正同時進行</td><td><code>ExecutorService.newFixedThreadPool(1)</code></td></tr><tr><td><strong>平行（真正同時執行）</strong></td><td>多個執行緒同時執行</td><td>需要多核心 CPU，真正並行</td><td><code>ExecutorService.newFixedThreadPool(3)</code></td></tr></tbody></table><hr><h2 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h2><ul><li><strong>序列（串行）</strong>：適合簡單任務，沒有同步問題，但效能較低。</li><li><strong>並發（交替執行）</strong>：適合 <strong>I&#x2F;O 密集型</strong> 任務，例如網路請求、檔案讀寫，因為大部分時間花在等待。</li><li><strong>平行（真正同時執行）</strong>：適合 <strong>CPU 密集型</strong> 任務，例如影像處理、數據計算，充分利用多核心 CPU。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MultiThread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看MSSQL資料庫的佔用空間</title>
      <link href="/2025/02/02/%E6%9F%A5%E7%9C%8BMSSQL%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E4%BD%94%E7%94%A8%E7%A9%BA%E9%96%93/"/>
      <url>/2025/02/02/%E6%9F%A5%E7%9C%8BMSSQL%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E4%BD%94%E7%94%A8%E7%A9%BA%E9%96%93/</url>
      
        <content type="html"><![CDATA[<p>在 MSSQL 中，可以通過系統檢視或內建存儲過程來查看資料庫的大小，包括資料和索引的占用。以下是常用的方法：</p><hr><h3 id="方法-1：使用-sp-spaceused"><a href="#方法-1：使用-sp-spaceused" class="headerlink" title="方法 1：使用 sp_spaceused"></a><strong>方法 1：使用 <code>sp_spaceused</code></strong></h3><p><code>sp_spaceused</code> 是一個內建的存儲過程，用於查看資料庫的空間使用情況。</p><h3 id="查看整個資料庫的大小"><a href="#查看整個資料庫的大小" class="headerlink" title="查看整個資料庫的大小"></a><strong>查看整個資料庫的大小</strong></h3><ol><li><p>切換到目標資料庫：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE [YourDatabaseName];</span><br><span class="line">GO</span><br></pre></td></tr></table></figure></li><li><p>執行以下命令：返回的關鍵結果：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_spaceused;</span><br></pre></td></tr></table></figure><ul><li><code>database_size</code>：資料庫的總大小（資料和索引）。</li><li><code>unallocated space</code>：未分配的空間。</li></ul></li></ol><h3 id="查看特定表的大小"><a href="#查看特定表的大小" class="headerlink" title="查看特定表的大小"></a><strong>查看特定表的大小</strong></h3><ol><li><p>執行以下命令：返回的關鍵結果：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_spaceused N<span class="string">&#x27;[YourTableName]&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>reserved</code>：表的總預留空間（資料、索引和未使用空間）。</li><li><code>data</code>：表中資料的大小。</li><li><code>index_size</code>：表的索引大小。</li><li><code>unused</code>：未使用的空間。</li></ul></li></ol><hr><h3 id="方法-2：使用-sys-master-files-和-sys-database-files"><a href="#方法-2：使用-sys-master-files-和-sys-database-files" class="headerlink" title="方法 2：使用 sys.master_files 和 sys.database_files"></a><strong>方法 2：使用 <code>sys.master_files</code> 和 <code>sys.database_files</code></strong></h3><p>可以直接從系統檢視中查詢資料庫文件的大小。</p><h3 id="查看資料庫的總大小"><a href="#查看資料庫的總大小" class="headerlink" title="查看資料庫的總大小"></a><strong>查看資料庫的總大小</strong></h3><p>執行以下查詢：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name <span class="keyword">AS</span> DatabaseName,</span><br><span class="line">    <span class="built_in">SUM</span>(size) <span class="operator">*</span> <span class="number">8</span> <span class="operator">/</span> <span class="number">1024</span> <span class="keyword">AS</span> SizeInMB</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sys.master_files</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    database_id <span class="operator">=</span> DB_ID(<span class="string">&#x27;YourDatabaseName&#x27;</span>) <span class="comment">-- 替換為資料庫名稱</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    name;</span><br></pre></td></tr></table></figure><ul><li><code>size</code>：每個文件的大小（以 8KB 頁為單位）。</li></ul><hr><h3 id="方法-3：使用-sys-dm-db-partition-stats"><a href="#方法-3：使用-sys-dm-db-partition-stats" class="headerlink" title="方法 3：使用 sys.dm_db_partition_stats"></a><strong>方法 3：使用 <code>sys.dm_db_partition_stats</code></strong></h3><p>這個動態管理檢視用於查看每個表和索引的空間使用情況。</p><h3 id="查看所有表的大小"><a href="#查看所有表的大小" class="headerlink" title="查看所有表的大小"></a><strong>查看所有表的大小</strong></h3><p>執行以下查詢：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t.NAME <span class="keyword">AS</span> TableName,</span><br><span class="line">    <span class="built_in">SUM</span>(a.total_pages) <span class="operator">*</span> <span class="number">8</span> <span class="keyword">AS</span> TotalSpaceKB,</span><br><span class="line">    <span class="built_in">SUM</span>(a.used_pages) <span class="operator">*</span> <span class="number">8</span> <span class="keyword">AS</span> UsedSpaceKB,</span><br><span class="line">    (<span class="built_in">SUM</span>(a.total_pages) <span class="operator">-</span> <span class="built_in">SUM</span>(a.used_pages)) <span class="operator">*</span> <span class="number">8</span> <span class="keyword">AS</span> UnusedSpaceKB</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sys.tables t</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    sys.indexes i <span class="keyword">ON</span> t.OBJECT_ID <span class="operator">=</span> i.object_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    sys.partitions p <span class="keyword">ON</span> i.object_id <span class="operator">=</span> p.OBJECT_ID <span class="keyword">AND</span> i.index_id <span class="operator">=</span> p.index_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    sys.allocation_units a <span class="keyword">ON</span> p.partition_id <span class="operator">=</span> a.container_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    TotalSpaceKB <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><ul><li><code>TotalSpaceKB</code>：表的總大小（包括資料和索引）。</li><li><code>UsedSpaceKB</code>：已使用的空間。</li><li><code>UnusedSpaceKB</code>：未使用的空間。</li></ul><hr><h3 id="方法-4：使用-sys-database-files-查看具體文件大小"><a href="#方法-4：使用-sys-database-files-查看具體文件大小" class="headerlink" title="方法 4：使用 sys.database_files 查看具體文件大小"></a><strong>方法 4：使用 <code>sys.database_files</code> 查看具體文件大小</strong></h3><p>執行以下查詢來查看資料庫中每個文件的大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name <span class="keyword">AS</span> FileName,</span><br><span class="line">    size <span class="operator">*</span> <span class="number">8</span> <span class="operator">/</span> <span class="number">1024</span> <span class="keyword">AS</span> SizeInMB,</span><br><span class="line">    physical_name <span class="keyword">AS</span> PhysicalPath,</span><br><span class="line">    type_desc <span class="keyword">AS</span> FileType</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sys.database_files;</span><br></pre></td></tr></table></figure><ul><li><code>FileType</code>：文件類型（<code>ROWS</code> 表示資料文件，<code>LOG</code> 表示日誌文件）。</li><li><code>SizeInMB</code>：文件大小（以 MB 為單位）。</li></ul><hr><h3 id="推薦方法"><a href="#推薦方法" class="headerlink" title="推薦方法"></a><strong>推薦方法</strong></h3><ul><li><strong>快速檢查資料庫大小：</strong> 使用 <code>sp_spaceused</code>。</li><li><strong>詳細查看所有表大小：</strong> 使用 <code>sys.dm_db_partition_stats</code>。</li><li><strong>檢查文件大小：</strong> 使用 <code>sys.database_files</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 資料庫(MSSQL) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSSQL </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分散式系統的CAP定理(CAP theorem)</title>
      <link href="/2024/09/21/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1%E7%9A%84CAP%E5%AE%9A%E7%90%86-CAP-theorem/"/>
      <url>/2024/09/21/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1%E7%9A%84CAP%E5%AE%9A%E7%90%86-CAP-theorem/</url>
      
        <content type="html"><![CDATA[<p>在設計分散式系統(Distributed System)前，必須要了解CAP定理(CAP theorem)，又稱布魯爾定理（Brewer’s theorem）。</p><p>CAP定理的三個字母C，A，P分別代表以下：</p><ul><li><strong>C</strong>onsistency：一致性</li><li><strong>A</strong>vailability：可用性</li><li><strong>P</strong>artition-tolerance：分區容錯</li></ul><h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>指分散式系統中的每個節點(nodes)所查到的都是一致且最新的資料。</p><h3 id="Availability-可用性"><a href="#Availability-可用性" class="headerlink" title="Availability 可用性"></a>Availability 可用性</h3><p>在任何時候，每次向系統發出請求都能在合理的時間內獲得回應，但並不保證回應的資料為最新。</p><h3 id="Partition-tolerance-分區容錯"><a href="#Partition-tolerance-分區容錯" class="headerlink" title="Partition-tolerance 分區容錯"></a>Partition-tolerance 分區容錯</h3><p>當網路或節點故障造成系統的不同網路分區間(Partitions)的傳輸資料丟失時，系統仍可以正常運作。</p><p>滿足以上三種特性是一個完美的分散式系統欲達成的目標。</p><p>不過CAP定理指出，一個分散式系統最多只能滿足以上三個特性中的兩個，而無法同時滿足三個。</p><blockquote><p>You can have at most two of these properties for any shared-data system</p></blockquote><p>因此在設計分散式系統時，只能從三個特性中取捨，最多只能選擇兩點來滿足，有下列組合：</p><ul><li>CP (Consistency and Partition Tolerant)：一致性與分區容錯。</li><li>AP (Availability and Partition Tolerant)：可用性與分區容錯。</li><li>CA (Consistency and Availability)： 一致性與可用性。</li></ul><h3 id="CP-Consistent-and-Partition-Tolerant"><a href="#CP-Consistent-and-Partition-Tolerant" class="headerlink" title="CP (Consistent and Partition Tolerant)"></a>CP (Consistent and Partition Tolerant)</h3><blockquote><p>在分區容錯的情況下保證資料的一致性，那就必須犧牲可用性。</p></blockquote><h3 id="AP-Availability-and-Partition-Tolerant"><a href="#AP-Availability-and-Partition-Tolerant" class="headerlink" title="AP (Availability and Partition Tolerant)"></a>AP (Availability and Partition Tolerant)</h3><blockquote><p>在分區容錯的情況下保證系統的可用性，那就必須犧牲資料的一致性。</p></blockquote><h3 id="CA-Consistent-and-Availability"><a href="#CA-Consistent-and-Availability" class="headerlink" title="CA (Consistent and Availability)"></a>CA (Consistent and Availability)</h3><blockquote><p>保證系統的可用性與資料一致，那就無法有分區容錯，也就是只有一個節點，這樣的情況就不是分散式系統了，不過這樣的系統可能並不存在。</p></blockquote><p>CAP定理的證明請參考<a href="https://strrl.dev/post/before-2022/brewers-conjecture-and-the-feasibility-of-consistent-available-partition-tolerant-web-services">Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</a>。</p><p>而分散式系統本身即為滿足分區容錯(P)的架構，也就是希望系統在部分節點或網路失靈的狀況下功能能可正常運作，因此通常是在CP與AP中作抉擇。</p>]]></content>
      
      
      <categories>
          
          <category> 名詞解釋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分散式(Distributed) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate → @DiscriminatorColumn說明</title>
      <link href="/2024/05/17/Hibernate-DiscriminatorColumn%E8%AA%AA%E6%98%8E/"/>
      <url>/2024/05/17/Hibernate-DiscriminatorColumn%E8%AA%AA%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><code>@DiscriminatorColumn</code> 註解用於在 JPA 繼承結構中，為單表策略 (<code>InheritanceType.SINGLE_TABLE</code>) 的繼承層次結構指定區分列。這樣，JPA 可以使用這個列來識別每一行對應的具體實體類型。</p><p>讓我們詳細解釋一下：</p><h3 id="註解部分"><a href="#註解部分" class="headerlink" title="註解部分"></a>註解部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;accountType&quot;, discriminatorType = DiscriminatorType.STRING)</span></span><br></pre></td></tr></table></figure><ul><li><code>@DiscriminatorColumn</code>：這個註解指定了用來區分不同實體類型的列。</li><li><code>name=&quot;accountType&quot;</code>：這指定了區分列的名稱為 <code>accountType</code>。這個列將會被添加到生成的單表中，用來存儲每一行對應的實體類型。</li><li><code>discriminatorType = DiscriminatorType.STRING</code>：這指定了區分列的類型為 <code>STRING</code>。區分列可以是 <code>STRING</code>、<code>CHAR</code> 或 <code>INTEGER</code>。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>當使用 <code>InheritanceType.SINGLE_TABLE</code> 繼承策略時，所有的繼承層次結構中的實體類型都會被映射到同一張表中。區分列 (<code>discriminator column</code>) 用來區分表中的每一行對應哪個具體的實體類型。例如，如果有一個 <code>AdminGroup</code> 基本類和兩個子類 <code>AdminUser</code> 和 <code>AdminManager</code>，這張表中的每一行會有一個 <code>accountType</code> 列來指示該行是 <code>AdminUser</code> 還是 <code>AdminManager</code>。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假設我們有以下實體類：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;accountType&quot;, discriminatorType = DiscriminatorType.STRING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminGroup</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;USER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminUser</span> <span class="keyword">extends</span> <span class="title class_">AdminGroup</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userSpecificField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;MANAGER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminManager</span> <span class="keyword">extends</span> <span class="title class_">AdminGroup</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String managerSpecificField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>對應的資料庫表可能如下：</p><table><thead><tr><th>id</th><th>name</th><th>accountType</th><th>userSpecificField</th><th>managerSpecificField</th></tr></thead><tbody><tr><td>1</td><td>AdminUser1</td><td>USER</td><td>someUserValue</td><td>NULL</td></tr><tr><td>2</td><td>AdminManager1</td><td>MANAGER</td><td>NULL</td><td>someManagerValue</td></tr></tbody></table><p>在這個表中，<code>accountType</code> 列用來區分每一行是 <code>AdminUser</code> 還是 <code>AdminManager</code>。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p><code>@DiscriminatorColumn</code> 註解告訴 JPA 在單表策略的繼承結構中，使用 <code>accountType</code> 列來區分不同的實體類型，並且這個列的類型是 <code>STRING</code>。這樣，JPA 就可以正確地將表中的每一行映射到相應的實體類。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap → computeIfAbsent()</title>
      <link href="/2024/03/21/HashMap-%E2%86%92-computeIfAbsent/"/>
      <url>/2024/03/21/HashMap-%E2%86%92-computeIfAbsent/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 當key不存在，就執行第二個參數的函數，並回傳執行後的值，然後也會put</span></span><br><span class="line"><span class="comment">// 如果函數返回 null，則不會put</span></span><br><span class="line"><span class="comment">// 如果函數本身拋出（未經檢查的）異常，則重新拋出異常，則不會put</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; stringLength = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stringLength.put(<span class="string">&quot;John&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stringLength.computeIfAbsent(<span class="string">&quot;John&quot;</span>, String::length);</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    System.out.println(<span class="string">&quot;stringLength = &quot;</span> + stringLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段程式碼看起來沒有明顯的錯誤，但可以做一些優化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    List&lt;FileTempRecord&gt; fileTempRecords = SSE_NOTIFY_IMAP.get(record.getCreatedBy());</span><br><span class="line">    <span class="keyword">if</span> (fileTempRecords == <span class="literal">null</span> || fileTempRecords.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        fileTempRecords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fileTempRecords.add(record);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fileTempRecords.add(record);</span><br><span class="line">    &#125;</span><br><span class="line">    SSE_NOTIFY_IMAP.put(record.getCreatedBy(), fileTempRecords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-computeIfAbsent-方法"><a href="#使用-computeIfAbsent-方法" class="headerlink" title="使用 computeIfAbsent() 方法"></a>使用 computeIfAbsent() 方法</h3><p>現在的程式碼需要先檢查一下 map 中是否有對應的 List，如果沒有的話就要建立一個新的 List。這個過程可以使用 computeIfAbsent() 方法來簡化，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    SSE_NOTIFY_IMAP.computeIfAbsent(record.getCreatedBy(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣，如果 SSE_NOTIFY_IMAP 中沒有對應的 List，computeIfAbsent() 方法會自動建立一個新的 ArrayList，並將 record 新增到 List 中。</p><h3 id="使用-Collection-addAll"><a href="#使用-Collection-addAll" class="headerlink" title="使用 Collection#addAll()"></a>使用 Collection#addAll()</h3><p>在原始程式碼中，如果 SSE_NOTIFY_IMAP 中已經有對應的 List，就需要分別使用 add() 方法來新增 record。實際上，我們可以使用 Collection#addAll() 方法來將一個集合中的所有元素新增到另一個集合中，這樣可以更簡潔的實現新增動作，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    List&lt;FileTempRecord&gt; fileTempRecords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fileTempRecords.add(record);</span><br><span class="line">    SSE_NOTIFY_IMAP.computeIfAbsent(record.getCreatedBy(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).addAll(fileTempRecords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣，如果 SSE_NOTIFY_IMAP 中已經有對應的 List，就會將 fileTempRecords 中的元素全部加到該 List 中。</p><p>綜上所述，我們可以使用下面的程式碼來優化原始程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotifyIMap</span><span class="params">(FileTempRecord record)</span> &#123;</span><br><span class="line">    SSE_NOTIFY_IMAP.computeIfAbsent(record.getCreatedBy(), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap → putIfAbsent()</title>
      <link href="/2024/03/20/HashMap-%E2%86%92-putIfAbsent/"/>
      <url>/2024/03/20/HashMap-%E2%86%92-putIfAbsent/</url>
      
        <content type="html"><![CDATA[<p>putIfAbsent() 是 HashMap 在 Java 中的一個實用方法，它屬於 Map 介面。這個方法用來在對應的鍵（key）不存在於映射中時，將一組key,value 放入映射(map)裡。如果映射先前已包含該鍵(key)的映射，則不做任何更動。putIfAbsent() 方法既可以確保不會不小心覆蓋已有的鍵值(key, value)，也可以用來在多執行緒環境下安全的更新map，假設映射本身是同步的或者是一個 ConcurrentHashMap。</p><p>方法簽名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span></span><br></pre></td></tr></table></figure><p>K: 鍵的類型</p><p>V: 值的類型</p><p>返回值：如果映射中已經有這個鍵，則返回鍵對應的舊值；如果沒有，則返回 null（並且將新的鍵值對插入映射）。</p><h3 id="範例1"><a href="#範例1" class="headerlink" title="範例1"></a>範例1</h3><p>以下是使用 putIfAbsent() 方法的一個簡單範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PutIfAbsentExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 建立一個 HashMap</span></span><br><span class="line">        Map&lt;String, Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向映射中新增一些資料</span></span><br><span class="line">        scores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        scores.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 putIfAbsent() 嘗試新增一個新的key,value</span></span><br><span class="line">        <span class="comment">// 由於 &quot;Alice&quot; 已存在，所以這個操作不會更改映射</span></span><br><span class="line">        scores.putIfAbsent(<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 嘗試新增資料，因為 &quot;Charlie&quot; 不存在，所以會被成功新增</span></span><br><span class="line">        scores.putIfAbsent(<span class="string">&quot;Charlie&quot;</span>, <span class="number">85</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 輸出map的內容</span></span><br><span class="line">        scores.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="範例2"><a href="#範例2" class="headerlink" title="範例2"></a>範例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// new HashMap</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增3個值</span></span><br><span class="line">        sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sites HashMap: &quot;</span> + sites);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增一個不存在的key，不存在就新增，普通put也一樣效果</span></span><br><span class="line">        sites.putIfAbsent(<span class="number">4</span>, <span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增一個存在的key，這裡如果是普通的put，那key2會被覆蓋，如果使用此方法則不會被覆蓋</span></span><br><span class="line">        sites.putIfAbsent(<span class="number">2</span>, <span class="string">&quot;Wiki&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Updated Languages: &quot;</span> + sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-Script 屬性</title>
      <link href="/2024/02/05/HTML-Scrpit-%E5%B1%AC%E6%80%A7/"/>
      <url>/2024/02/05/HTML-Scrpit-%E5%B1%AC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="src屬性"><a href="#src屬性" class="headerlink" title="src屬性"></a>src屬性</h2><p>src 屬性指定外部腳本的 URL，允許開發者將 JavaScript 程式碼組織在單獨檔案中，而非直接寫在 HTML 內。當<code>&lt;script&gt;</code>標籤包含src屬性時，不應包含嵌入式腳本程式碼。</p><h2 id="type屬性"><a href="#type屬性" class="headerlink" title="type屬性"></a>type屬性</h2><p>type 屬性聲明腳本的 MIME 類型 (現已非必需，因為現代瀏覽器預設使用JavaScript)。早期 HTML 規範中，這個屬性用來指示腳本語言的類型，如”<code>text/javascript</code>“ 或 “<code>application/javascript</code>“。</p><h2 id="async屬性"><a href="#async屬性" class="headerlink" title="async屬性"></a>async屬性</h2><p>async 屬性是個布林屬性，告訴瀏覽器非同步的載入檔案。這意味著腳本會在下載完畢後儘快執行，但不會阻塞 HTML 文件的解析。此屬性僅適用於帶有src屬性的<code>&lt;script&gt;</code>標籤。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;xxx/script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br></pre></td></tr></table></figure><h2 id="defer屬性"><a href="#defer屬性" class="headerlink" title="defer屬性"></a>defer屬性</h2><p>與async屬性類似，defer屬性也會指示瀏覽器非同步載入腳本，但有個關鍵不同：帶有 <code>defer</code> 屬性的腳本保證會在文件解析完成後、DOMContentLoaded事件觸發前，按照它們在檔案中出現的順序執行。這也僅適用於帶有src屬性的腳本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;xxx/script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/pw/ABLVV84LFnpNsdPgLjmE_CLpESaZqTb9sD7TZZL4emfhvxPNJk1LJarVlUoyuzQQ6cwyBF-aDnfwtf68wwGfZge7ZE2VriXEFNZXE1RgkSW2Ym_1DTaCNuk=w800" alt="時序圖"><br> (圖片來源：<a href="https://medium.com/@nikjohn/speed-up-google-maps-and-everything-else-with-async-defer-7b9814efb2b">Speed up Google Maps(and everything else) with async &amp; defer</a>)</p><h2 id="crossorigin屬性"><a href="#crossorigin屬性" class="headerlink" title="crossorigin屬性"></a>crossorigin屬性</h2><p><code>crossorigin</code> 屬性用於設定與跨源資源共享 (CORS) 相關設定。對於從CDN等不同來源載入的腳本特別重要。它可設為”<code>anonymous</code>“(不會發送用戶憑證) 或 “<code>use-credentials</code>“ (會發送使用者憑證)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.example.com/library.js&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="integrity屬性"><a href="#integrity屬性" class="headerlink" title="integrity屬性"></a>integrity屬性</h2><p><code>integrity</code> 屬性提供了一種安全特性，允許瀏覽器驗證取得的資源是否未經篡改。透過與腳本匹配的Hash值 (如SHA-256) 來確保腳本的完整性。<br>當瀏覽器載入帶有 <code>integrity</code> 屬性的資源時，它會計算從網絡上取得的文件的Hash值，並與<code>integrity</code>屬性中指定的Hash值進行比對：<br>如果兩個Hash值相同，則認為這個檔案是安全的，未被篡改，瀏覽器將正常載入和執行該檔案。<br>如果Hash值不同，則表示檔案可能在傳輸過程中被篡改，瀏覽器會拒絕載入該文件，以保護 Client 免受潛在的安全風險。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.example.com/library.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-Hash值&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-MySql</title>
      <link href="/2024/01/27/Docker-MySql/"/>
      <url>/2024/01/27/Docker-MySql/</url>
      
        <content type="html"><![CDATA[<p>新增檔案將內容貼上後，將檔案命名為<code>docker-compose.yml</code>，再執行<code>docker-compose up -d</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">linux/amd64</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=sample</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=demouser</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=e23s5</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volumes:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./conf.d/mysql.cnf:/etc/mysql/conf.d/mysql.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./init.d:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_cheng</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;23506:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">pj_network:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">pj_network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-Solr Compose</title>
      <link href="/2024/01/12/Docker-Solr-Compose/"/>
      <url>/2024/01/12/Docker-Solr-Compose/</url>
      
        <content type="html"><![CDATA[<p>本機開發時會用到，遇到要升級時需要測試環境，所以本機使用 Docker 建立 Solr6，然後在 VM 上建立 Solr8</p><h2 id="Solr-6"><a href="#Solr-6" class="headerlink" title="Solr 6"></a>Solr 6</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.7</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2181:2181&quot;</span></span><br><span class="line">  <span class="attr">solr:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">solr:6.6.3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8983:8983&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data:/var/solr</span></span><br><span class="line">      <span class="comment">#- ./init-solr.sh:/docker-entrypoint-initdb.d/init-solr.sh</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZK_HOST=zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SOLR_HOST=127.0.0.1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JETTY_PORT=8983</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">solr-foreground</span></span><br><span class="line">    <span class="comment">#command: [&quot;sh&quot;, &quot;/docker-entrypoint-initdb.d/init-solr.sh&quot;]</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>將文件存檔為 <code>docker-compose.yml</code> ，開啟終端機並且移動到該檔案的同一層目錄，執行指令 <code>docker-compose up -d</code> 服務啟動後，進入到容器 <code>docker exec -it solr-solr-1 bash</code> 執行指令建立 <code>Collection</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/opt/solr/bin/solr create_collection -d /opt/solr/server/solr/configsets/basic_configs -c line -shards 1 -replicationFactor 1</span><br><span class="line"></span><br><span class="line">/opt/solr/bin/solr create_collection -d /opt/solr/server/solr/configsets/basic_configs -c apilog -shards 1 -replicationFactor 1</span><br></pre></td></tr></table></figure><h2 id="Solr-8"><a href="#Solr-8" class="headerlink" title="Solr 8"></a>Solr 8</h2><p>此安裝的作業系統為 <code>CentOS 8</code>，下載 Solr 8.11.2 <a href="https://dlcdn.apache.org/lucene/solr/8.11.2">https://dlcdn.apache.org/lucene/solr/8.11.2</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlcdn.apache.org/lucene/solr/8.11.2/solr-8.11.2.zip</span><br></pre></td></tr></table></figure><p>解壓縮目錄</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip solr-8.11.2.zip</span><br></pre></td></tr></table></figure><p>進入 <code>solr-8.11.2/bin</code> 目錄，啟動 <code>Cloud</code> 指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr start -e cloud -force</span><br></pre></td></tr></table></figure><p>要注意防火牆要開通8983(solr), 9983(zk)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8983/tcp --permanent</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9983/tcp --permanent</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell-取得上一個月的事件錯誤記錄</title>
      <link href="/2024/01/05/PowerShell-%E5%8F%96%E5%BE%97%E4%B8%8A%E4%B8%80%E5%80%8B%E6%9C%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%8C%AF%E8%AA%A4%E8%A8%98%E9%8C%84/"/>
      <url>/2024/01/05/PowerShell-%E5%8F%96%E5%BE%97%E4%B8%8A%E4%B8%80%E5%80%8B%E6%9C%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%8C%AF%E8%AA%A4%E8%A8%98%E9%8C%84/</url>
      
        <content type="html"><![CDATA[<p>最近要將每月的報告自動化，所以使用PowerShell來取得一些記錄，要取得的記錄是事件檢視器前一個月的「應用程式」、「安全性」、「系統」各個的錯誤事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">month = Get-Date -Format <span class="string">&#x27;MM&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">year = Get-Date -Format <span class="string">&#x27;yyyy&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">dir</span> = <span class="string">&#x27;EventLog&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">if($</span><span class="language-bash">month -eq 1)&#123;</span></span><br><span class="line">    $year = $year-1</span><br><span class="line">    $month = 12</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $month = $month-1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">last = [DateTime]::DaysInMonth(<span class="variable">$year</span>, <span class="variable">$month</span>)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">first = Get-Date -Day 1 -Month <span class="variable">$month</span> -Year <span class="variable">$year</span> -Hour 0 -Minute 0 -Second 0</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">last = Get-Date -Day <span class="variable">$last</span> -Month <span class="variable">$month</span> -Year <span class="variable">$year</span> -Hour 23 -Minute 59 -Second 59</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">hostIP = ([System.Net.DNS]::GetHostAddresses(<span class="variable">$env</span>:COMPUTERNAME) |Where-Object &#123;<span class="variable">$_</span>.AddressFamily -eq <span class="string">&quot;InterNetwork&quot;</span>&#125; | select-object IPAddressToString)[0].IPAddressToString</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">events=@(<span class="string">&#x27;Application&#x27;</span>,<span class="string">&#x27;System&#x27;</span>,<span class="string">&#x27;Security&#x27;</span>)</span></span><br><span class="line"> </span><br><span class="line">Function EventLogger($message)&#123;</span><br><span class="line">    $nowTime = get-date -Format &#x27;yyyy-MM-dd HH:mm:ss&#x27;</span><br><span class="line">    Write-Output $nowTime $message &gt;&gt; $env:USERPROFILE\EventLog.log</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">try&#123;</span><br><span class="line">    Foreach($eventName in $events)&#123;</span><br><span class="line">        switch($eventName)&#123;</span><br><span class="line">            &quot;Security&quot; &#123;</span><br><span class="line">               $info = Get-EventLog Security | Where-Object &#123;$_.TimeGenerated -ge $first -and $_.TimeGenerated -le $last&#125; | Where-Object &#123;$_.EntryType -eq &#x27;FailureAudit&#x27;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">            Default &#123;</span><br><span class="line">               $info = Get-WinEvent -FilterHashtable @&#123;</span><br><span class="line">                   LogName=$eventName;</span><br><span class="line">                   Level=1,2;</span><br><span class="line">                   StartTime=$first;</span><br><span class="line">                   EndTime=$last;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if($info.Count -ne 0)&#123;</span><br><span class="line">            $info | Export-Csv -Path $env:USERPROFILE\$env:COMPUTERNAME-$hostIP-Log-$year$month-$eventName.csv -Encoding &quot;UTF8&quot;         </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            EventLogger $eventName&#x27; no event records&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        EventLogger $eventName&#x27; scan end&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch&#123;</span><br><span class="line">    EventLogger $Error[0].Exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
